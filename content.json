{"meta":{"title":"湿科技","subtitle":"Dancing With Tech","description":"","author":"Chaos John","url":"https://blog.chaosjohn.com","root":"/"},"pages":[],"posts":[{"title":"git 设置远端仓库","slug":"Git-set-remote","date":"2020-12-04T09:27:41.000Z","updated":"2020-12-04T14:27:01.645Z","comments":true,"path":"Git-set-remote.html","link":"","permalink":"https://blog.chaosjohn.com/Git-set-remote.html","excerpt":"","text":"前段时间，公司开了一个新项目，买了另一家公司的源码做二次开发。 项目进行了几天后，我突然听到参与开发的几个同学在讨论，关于 “不想把我们修改的版本推给他们”。 我就顿感奇怪，买了源码还要遵循他们的开源协议？ 我跑过去问问怎么回事，一听就乐了。原来对方公司将代码部署在私有 git 服务器上，给了我们账号密码以供拉取源码。对方承诺对产品做后续的更新维护，新版本也发布在该 git 仓库上。但是我们对源码做二次开发，会进行很多改动，又不想把我们的改动推给他们。 啊这。。。明显是对 git 不熟悉啊，而且还不是一个同学，应该值得反省。平日里起草招聘需求时都会把 git 作为一个必备的技能项，结果轮到自己身上，却只略知皮毛。 我先代入他们的思维反过来推理：为什么一定要 push，他们的代码只做 pull，拉取新版合并到本地不就行了么。哦，原来不止一个小伙伴在协同开发，相互间要共享改动，比如 A同学 的改动 push 后 B同学 pull 后才能看到。那 push 后不就推送到了对方公司的 git 服务器了么。 所以小伙伴们还停留在一个 git 仓库只有一个远端的层面。 其实一个 git 仓库是可以配置多个远端 remote。 我们举个例子来模拟一下，我们从 github 上随便 clone 一个项目下来 12345678$ git clone git@github.com:taniarascia&#x2F;takenote.gitCloning into &#39;takenote&#39;...remote: Enumerating objects: 114, done.remote: Counting objects: 100% (114&#x2F;114), done.remote: Compressing objects: 100% (92&#x2F;92), done.remote: Total 4672 (delta 44), reused 50 (delta 20), pack-reused 4558Receiving objects: 100% (4672&#x2F;4672), 10.13 MiB | 780.00 KiB&#x2F;s, done.Resolving deltas: 100% (2990&#x2F;2990), done. 我们查看一下 git配置： 123456789101112131415$ cd takenote$ cat .git&#x2F;config[core] repositoryformatversion &#x3D; 0 filemode &#x3D; true bare &#x3D; false logallrefupdates &#x3D; true ignorecase &#x3D; true precomposeunicode &#x3D; true[remote &quot;origin&quot;] url &#x3D; git@github.com:taniarascia&#x2F;takenote.git fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*[branch &quot;master&quot;] remote &#x3D; origin merge &#x3D; refs&#x2F;heads&#x2F;master 我们可以看到 只有一个 远端(remote) - origin，并且指向了 &#103;&#105;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;:taniarascia/takenote.git 只有一个 分支(master) 接下来去 码云Gitee 上去创建一个 空的 私有仓库，模拟存放我们的 已修改源码 创建后会跳转到仓库主页 我们可以看到，对于已存在的本地仓库，是可以直接推送到 码云 的 12git remote add origin git@gitee.com:ChaosJohn&#x2F;takenote.gitgit push -u origin master 解释一下第一行：添加一个 远端(remote)，取名为 origin，设置 远端地址 为 git@gitee.com:ChaosJohn/takenote.git 可以预见，如果直接执行，肯定会报错，先试试： 12$ git remote add origin git@gitee.com:ChaosJohn&#x2F;takenote.gitfatal: remote origin already exists. 报错提示说：名叫 origin 的远端已存在。 那咱就换一个呗，不如取名 gitee 吧，正好寓意这个远端是 码云 的，再次执行 git remote add gitee git@gitee.com:ChaosJohn/takenote.git 无报错。 查看一下配置文件，发现比之前的多了三行 1234567891011121314151617$ cat .git&#x2F;config[core] repositoryformatversion &#x3D; 0 filemode &#x3D; true bare &#x3D; false logallrefupdates &#x3D; true ignorecase &#x3D; true precomposeunicode &#x3D; true[remote &quot;origin&quot;] url &#x3D; git@github.com:taniarascia&#x2F;takenote.git fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*[branch &quot;master&quot;] remote &#x3D; origin merge &#x3D; refs&#x2F;heads&#x2F;master[remote &quot;gitee&quot;] url &#x3D; git@gitee.com:ChaosJohn&#x2F;takenote.git fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;gitee&#x2F;* 其实直接将这三行添加到 .git/config 文件内，等同与执行 git remote add 命令。 所以正确的 git 工作流程为： 从当前 master 分支创建新的 开发分支 git checkout -b dev 在 dev 分支上做二次开发，提交并且推送到 码云远端 git push -u gitee dev 如果原项目出更新内容了，先切回到 master 分支，然后从 github远端 拉取新代码 git pull origin master 再将 master 分支合并到 dev 分支 切换到 dev 分支，继续做二次开发以及推送到码云，如此循环迭代 所以建议所有开发的小伙伴们，有时间要多去学习和熟悉 git。毕竟 工欲善其事 必先利其器 嘛！！！ 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://blog.chaosjohn.com/tags/git/"}]},{"title":"git set remote","slug":"git-set-remote","date":"2020-12-04T09:27:41.000Z","updated":"2020-12-04T09:27:41.682Z","comments":true,"path":"git-set-remote.html","link":"","permalink":"https://blog.chaosjohn.com/git-set-remote.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"解决 Composer 报错 InvalidArgumentException","slug":"Fix-InvalidArgumentException-for-Composer","date":"2020-12-03T09:37:32.000Z","updated":"2020-12-04T01:39:22.006Z","comments":true,"path":"Fix-InvalidArgumentException-for-Composer.html","link":"","permalink":"https://blog.chaosjohn.com/Fix-InvalidArgumentException-for-Composer.html","excerpt":"","text":"composer 在 2020-11-24 发布了全新的 2.0 版本。参考官方博客 鉴于博客里描述新版在很多方面都做出了优化，特别是性能方面，提速了很多，于是笔者迫不及待地更新了。 但是在写上一篇文章 php 调试指南（Xdebug版）的篇头处，执行 composer require mikecao/flight 却发生了异常 1234567891011[RuntimeException]No composer.json present in the current directory, this may be the cause of the following exception.[InvalidArgumentException]Could not find package mikecao&#x2F;flight.Did you mean one of these? mikecao&#x2F;flight geogkary&#x2F;breeze 分析报错信息，提示找不到 mikecao/flight，又问我是不是想找 mikecao/flight。 这。。。有毒吧 会不会是 Composer 2.0 的 bug？不科学呀，不至于有这么大的bug还发布了出来。 会不会是我的配置有问题？查看一下 配置文件 12345678910$ cat ~&#x2F;.composer&#x2F;config.json&#123; &quot;config&quot;: &#123;&#125;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;packagist.phpcomposer.com&quot; &#125; &#125;&#125; 可以看到除了 镜像源 以外并无其他的配置。 问题会不会出在 镜像源 上呢，反正排除法就那么多选项 删除 镜像源 删除 composer 二进制文件以及程序目录 $HOME/.composer 后重装 将 config.json 的 packagist 块删除后（亦可执行 composer config -g --unset repos.packagist），再次执行 require 12345678910111213$ composer require mikecao&#x2F;flightUsing version ^1.3 for mikecao&#x2F;flight.&#x2F;composer.json has been updatedRunning composer update mikecao&#x2F;flightLoading composer repositories with package informationUpdating dependenciesLock file operations: 1 install, 0 updates, 0 removals - Locking mikecao&#x2F;flight (v1.3.8)Writing lock fileInstalling dependencies from lock file (including require-dev)Package operations: 1 install, 0 updates, 0 removals - Installing mikecao&#x2F;flight (v1.3.8): Extracting archiveGenerating autoload files Bingo! 异常报错消失了 可是该镜像源 Packagist / Composer 中国全量镜像 笔者已经使用了好多年了，怎么突然就挂了呢？网上也搜不到它的 停服 消息。 考虑到国内的网络环境，得重新找一个镜像源。 经过一番网罗，笔者最终敲定选用 阿里云 Composer 全量镜像，配置命令： 1$ composer config -g repo.packagist composer https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F; 其他的推荐镜像源： 华为云 https://mirrors.huaweicloud.com/repository/php/ 次选镜像源： 腾讯云 https://mirrors.cloud.tencent.com/composer/ 上海交通大学 https://packagist.mirrors.sjtug.sjtu.edu.cn 列为次选是因为还未支持 Composer2，运行时会有 黄色警告 1Composer 2 repository support for https:&#x2F;&#x2F;mirrors.xxx.com&#x2F;composer has been disabled due to what seems like a misconfiguration. If this is a packagist.org mirror we recommend removing it as Composer 2 handles network operations much faster and should work fine without. 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"fix","slug":"fix","permalink":"https://blog.chaosjohn.com/tags/fix/"},{"name":"composer","slug":"composer","permalink":"https://blog.chaosjohn.com/tags/composer/"}]},{"title":"php 调试指南（Xdebug版）","slug":"Debug-php","date":"2020-12-01T15:33:41.000Z","updated":"2020-12-02T16:27:57.039Z","comments":true,"path":"Debug-php.html","link":"","permalink":"https://blog.chaosjohn.com/Debug-php.html","excerpt":"","text":"（吃透本文，没有人将比你更懂 **Php Xdebug 调试**） 创建一个精简项目（命令行）创建项目，并且用 composer 安装一个笔者比较喜欢的 微框架，作为示例 123$ mkdir debug$ cd debug$ composer require mikecao&#x2F;flight 编写主程序 index.php 12345678910cat &gt;&gt; index.php &lt;&lt;EOF&lt;?phprequire &#39;vendor&#x2F;autoload.php&#39;;Flight::route(&#39;&#x2F;&#39;, function()&#123; echo &#39;hello world!&#39;;&#125;);Flight::start();EOF 用 php 内置服务器运行项目 12345$ php -S localhost:8080[Tue Dec 1 23:31:12 2020] PHP 7.4.13 Development Server (http:&#x2F;&#x2F;localhost:8080) started[Tue Dec 1 23:31:35 2020] [::1]:57780 Accepted[Tue Dec 1 23:31:35 2020] [::1]:57780 [200]: GET &#x2F;[Tue Dec 1 23:31:35 2020] [::1]:57780 Closing 上面输出的后三行，是在本机另一终端访问 http://localhost:8080 时打印的日志 12$ curl -L localhost:8080hello world! （使用 php 内置服务器运行项目，只是为了检测项目是否能完好运行；该内置服务器只能用于开发环境，不能用于生产环境） 转移开发至 PhpStorm 中JetBrains 公司出品的 PhpStorm 与其安装在此不做赘述。 在 PhpStorm 中打开项目 打开 偏好设置（mac下快捷键为 Command+, Win/Linux下快捷键为 Ctrl+Alt+s），左边侧边栏定位到 Languages &amp; Frameworks =&gt; PHP 在这里添加此前于 PHPBrew 中安装的 PHP 版本。参考前文 PHPBrew 使用指南（注意：请务必安装 xdebug 扩展：$phpbrew ext install xdebug，否则无法进行调试） 将刚刚添加上的 PHP 版本应用到当前项目 用 Nginx 运行项目安装与管理 无视系统环境 - 编译安装，不做赘述 macOS12$ brew install nginx$ brew services start&#x2F;stop&#x2F;restart nginx # 启动&#x2F;停止&#x2F;重启 nginx Debian / Ubuntu123$ sudo apt update$ sudo apt install nginx-full$ sudo systemctl start&#x2F;stop&#x2F;restart nginx # 启动&#x2F;停止&#x2F;重启 nginx RHEL / CentOS123$ sudo yum update$ sudo apt install nginx$ sudo systemctl start&#x2F;stop&#x2F;restart nginx # 启动&#x2F;停止&#x2F;重启 nginx 配置（本文以 macOS 下 Homebrew 版 Nginx 为例）启动 php-fpm（用 PHPBrew 安装 PHP 时需要包含 +fpm variant） 12$ phpbrew fpm startStarting php-fpm... 在项目根目录下创建 nginx.conf 作为 Nginx 的配置文件 1234567891011121314server &#123; server_name localhost; listen 8000; root &#x2F;Users&#x2F;chaos&#x2F;Work&#x2F;php&#x2F;demos&#x2F;debug; location &#x2F; &#123; try_files $uri $uri&#x2F; &#x2F;index.php; fastcgi_pass unix:&#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13&#x2F;var&#x2F;run&#x2F;php-fpm.sock; fastcgi_index index.php; include fastcgi.conf; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; &#125;&#125; 将该配置文件 软链接 到 Nginx 配置目录下 /usr/local/etc/nginx/servers/ 1$ ln -sf &#x2F;Users&#x2F;chaos&#x2F;Work&#x2F;php&#x2F;demos&#x2F;debug&#x2F;nginx.conf &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;servers&#x2F;php-debug.conf 检查 nginx.conf 是否有错误 123$ nginx -tnginx: the configuration file &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful 启动 Nginx 12$ brew services start nginx&#x3D;&#x3D;&gt; Successfully started &#96;nginx&#96; (label: homebrew.mxcl.nginx) 终端下 curl 访问 Nginx部署的服务，验证项目成功跑了起来 12$ curl -L localhost:8000hello world! Xdebug 调试大部分关于 Xdebug 的配置，在前面部分已经配置完毕，我们来验证一下是否配置成功PhpStorm 顶部菜单栏点击 Run，在下拉菜单中选中 Web Server Debug Validation，弹出窗口中点击底部的 Validate 按钮。 如果显示成功，则调试环境已经搭建完毕 如果显示出错，会给出排错信息 发现三处警告，按照排错信息排查，发现问题出在了 Xdebug 3.0.0 版本变动了非常多的地方，导致目前 PhpStorm 最新的稳定版 2020.2.4 对此兼容性欠缺。不过 2020.3 有望解决。 所以笔者将 Xdebug 降级到了 2.X 版本：phpbrew ext install xdebug 2.9.8，再次点击 Validate 按钮，怎么还是一样的报错？ 这里我们查看 php-fpm 的信息 12345$ phpbrew fpm info...xdebug support &#x3D;&gt; enabledVersion &#x3D;&gt; 3.0.0... 所以需要重启一下 php-fpm，让其加载新的 Xdebug 模块 12345678$ phpbrew fpm restartStopping php-fpm...Starting php-fpm...$ phpbrew fpm info...xdebug support &#x3D;&gt; enabledVersion &#x3D;&gt; 2.9.8... 再次点击 Validate 按钮 依旧报错，不过这里就清晰很多了，照着提示，phpbrew config 直接调用编辑器打开 php.ini 文件，在尾部添加： 12[xdebug]xdebug.remote_enable&#x3D;1 待 phpbrew fpm restart 后再次点击 Validate 按钮，成功！ 这就可以愉快的调试部署在 Nginx 里的项目啦，这里我们点击工具栏的 监听按钮，开始监听连接请求 浏览器作为请求客户端进行调试为浏览器安装插件 Xdebug Helper for Firefox 源码 Xdebug Helper for Chrome 源码 这里笔者以 Chrome 浏览器为例，安装完后，右键 Xdebug Helper 图标点击 Options 打开选项页，选择 IDE key 为 PhpStorm 新开浏览器窗口，地址栏输入localhost:8000访问服务，页面会显示 **hello world!**。单击 Xdebug Helper 图标，点击 Debug，开启调试模式，至此，图标将会变成绿色（或者使用 Alt+Shift+X 快捷键快速开关 Debug 模式） 准备开始调试： 确保 PhpStorm 的 监听 按钮已激活 在 PhpStorm 中给需要调试的代码行打上断点 确保浏览器的 Xdebug Helper处于 Debug 模式，图标变为绿色 刷新浏览器页面，PhpStorm 监听到请求传入，同时浏览器请求处于 Pending 状态，挂起等待请求响应 在弹窗中选择完正确的 php 文件后，PhpStorm 就进入了调试模式，成功地停在了断点处，在这里可以查看当前的各项 变量 以及单步运行 点击调试窗口左侧的 Resume Program 按钮，程序从断点处恢复运行，至此，浏览器侧的请求收到了等待已久的响应，在窗口渲染出 hello world! 字样 命令行 或其他 请求客户端 发起调试在实际的纯接口开发场景中，除了类似 localhost:8000 的简单请求，还有诸多带有复杂参数的请求，以及各种 http method 的请求（GET / POST / PUT / HEAD / DELETE / OPTIONS），仅仅通过浏览器地址栏进行发起调试并不能胜任。 开发人品平时发起请求测试，一般都选用 命令行工具（例如 curl / httpie）或类似 Postman 这样的专业请求调试客户端。 通过查阅Xdebug 官方文档，得知，浏览器的插件开启 Debug 模式，仅仅是给当前session增加了一个 Cookie: XDEBUG_SESSION=PHPSTORM 那就简单了，以 curl 举例的三种方式： $ curl -H &quot;Cookie: XDEBUG_SESSION=PHPSTORM&quot; localhost:8000 $ curl --cookie XDEBUG_SESSION=PHPSTORM localhost:8000 $ curl -b XDEBUG_SESSION=PHPSTORM localhost:8000 Postman 也类似，不再赘述 至此，在 PhpStorm 调试部署在 Nginx 中的项目，杀青！ 提出疑问还记得前面有一张关于配置 php解释器 图么（重新搬运放在本段下方），里面明明配置了 Xdebug 的参数，而 Web Server Debug Validation 还是提示要去 php.ini 中添加 xdebug.remote_enable=1 JetBrains 肯定不会那么无聊，放置一个无用的配置项在这里。那这个配置项究竟对哪块地方生效呢？ PhpStorm 工具栏点击 Add Configuration，点击 + 号，选择 PHP Build-in Web Server，端口改为 8088 (或其他未被占用端口) 选择刚刚新建的 运行配置 php build-in server，点击右侧 绿色三角按钮，运行项目（同时确保 监听按钮 也已激活） 再次在命令行下执行： 1$ curl -H &quot;Cookie: XDEBUG_SESSION&#x3D;PHPSTORM&quot; localhost:8000 Bingo!!! PhpStorm 成功进入了调试状态并且停在了断点处！ 发散 1: 在 PhpStorm 调试 远程服务上文描述的都是调试本地环境，即服务部署在本地 Nginx，通过本地的 php-fpm 调用 php 解释器 进行请求分发处理，“加载”的是本地的 Xdebug（调试端口为默认的 9000），而同时 PhpStorm 也监听本地的 Xdebug 的 9000 端口进行拦截调试。 可往往更多的情况是，服务并不部署在本地，而在 远端服务器，这个时候得如何调试呢？ 接下来在 另一台主机(192.168.1.101) 上调试 本机(192.168.1.100) 的服务，来模拟现实开发中的 远程调试。 本机(192.168.1.100) 上在 php.ini 尾部添加 xdebug.remote_connect_back=1 另一台主机(192.168.1.101) 的 PhpStorm 点击工具栏上的 监听按钮 开启监听，并且在代码窗口设置断点 在 该主机(192.168.1.101) 的终端上执行 1$ curl -H &quot;Cookie: XDEBUG_SESSION&#x3D;PHPSTORM&quot; 192.168.1.100:8000 即可看到 PhpStorm 进入了调试模式并且顺利停在了断点处。 发散 2：在 VSCode 中调试 本地服务打开 VSCode，安装 PHP Debug 扩展 打开项目工程，点击左边栏的 Run，点击 Create a launch.json file，选择 PHP 环境 VSCode 将会自动创建两个配置： Listen for XDebug：这个配置就是类似 PhpStorm 中的 监听按钮 Launch currently open script：执行按照 php-cli 模式运行/调试 当前窗口的php脚本 选择 Listen for XDebug 并点击左侧的 绿色图标 开始运行监听，并且打上断点，命令行下执行 curl --cookie XDEBUG_SESSION=VSCODE localhost:8000，则能看到VSCode 成功进入了调试状态并且停在了断点处。 发散 3：在 VSCode 调试 远程服务与 发散 1 类似，在 另一台主机(192.168.1.101) 上： 确保 php.ini 已添加 xdebug.remote_connect_back=1 选择 Listen for XDebug 并点击左侧的 绿色图标 开始运行监听，并且打上断点 命令行下执行 curl --cookie XDEBUG_SESSION=VSCODE 192.168.1.100:8000 则能看到VSCode 成功进入了调试状态并且停在了断点处。 所以，在 VSCode 调试部署在 Nginx 中的服务（本地与远程），也顺利杀青！ 一些 思考 或 疑惑 Xdebug 的 IDE key（即使在 php.ini 中配置了 xdebug.idekey=xxx）在 远程调试 时并不起作用，调试请求时在 Cookie 中附加的 XDEBUG_SESSION 设置任意非空字符串都生效。是 Xdebug 的 bug 么？ 无论采用 PhpStorm 还是 VSCode 进行远程调试中，明明远程服务器的 Xdebug 调试端口（默认为9000）对外不可达（仅 localhost 可访问），但是 打上断点 开启监听 又能调试了呢？ 多人协同调试，参考 JetBrains 文档 Multiuser debugging via Xdebug proxies 使用 DBGp代理 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"debug","slug":"debug","permalink":"https://blog.chaosjohn.com/tags/debug/"},{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"xdebug","slug":"xdebug","permalink":"https://blog.chaosjohn.com/tags/xdebug/"}]},{"title":"PHPBrew 使用指南","slug":"Using-phpbrew","date":"2020-12-01T02:50:12.000Z","updated":"2020-12-02T02:03:49.844Z","comments":true,"path":"Using-phpbrew.html","link":"","permalink":"https://blog.chaosjohn.com/Using-phpbrew.html","excerpt":"","text":"前言咋一看，这个名字取得，肯定是跟 Homebrew 学的。既然 Homebrew 的定位是 macOS 上的 包管理器，那 PHPBrew 肯定也跟 包管理器 沾点边。没错，它可以用来 构建 和 安装 多个版本的 php 到用户主目录($HOME)下。 项目主页 抄一下 PHPBrew 的特性: 编译配置选项简化为variant，不用再过于担心搜寻路径 通过不同的variant(比如PDO, mysql, sqlite, debug等等)进行构建php 编译 apache 和 nginx 模块，并且按不同版本区分 构建和安装到用户主目录下，免去root权限 版本间易于切换，且与bash/zsh集成 自动特性检测 易于安装和启用 php扩展 到当前环境 支持安装多个版本的 php 到系统环境中 为 Homebrew 和 MacPorts 优化路径检测 环境需求 平台支持 Mac OS 10.5+ Ubuntu Debian RHEL / CentOS 依赖需求 PHP5.3+ bz2 curl gcc, binutils, autoconf, libxml, zlib, readline 各平台上的依赖安装请参考官方文档，这里笔者仅附上 Mac OS + Homebrew 和 Ubuntu 20.04的安装命令 Mac OS12$ xcode-select --install$ brew install autoconf pkg-config Ubuntu 20.0412$ sudo apt update$ sudo apt install build-essential libbz2-dev libreadline-dev libsqlite3-dev libssl-dev libxml2-dev php7.4-cli php7.4-bz2 pkg-config 安装下载 12$ curl -L -O https:&#x2F;&#x2F;github.com&#x2F;phpbrew&#x2F;phpbrew&#x2F;releases&#x2F;latest&#x2F;download&#x2F;phpbrew.phar$ chmod +x phpbrew.phar 安装到配置在 $PATH 环境变量里的bin目录，比如官方文档里的 /usr/local/bin（笔者用的是 $HOME/bin） 1sudo mv phpbrew.phar &#x2F;usr&#x2F;local&#x2F;bin&#x2F;phpbrew 设置初始化shell环境 1$ phpbrew init init 指令将会创建 $HOME/.phpbrew 目录 将下面一行加入 .bashrc 或者 .zshrc 1[[ -e ~&#x2F;.phpbrew&#x2F;bashrc ]] &amp;&amp; source ~&#x2F;.phpbrew&#x2F;bashrc 设置搜寻路径前缀设置默认的搜寻路径前缀，用于搜寻依赖库，可选项有 macports, homebrew, debian, ubuntu 或者 自定义路径 Homebrew用户1$ phpbrew lookup-prefix homebrew MacPorts用户1$ phpbrew lookup-prefix macports 基本用法列举已知的版本 12345678910$ phpbrew known&#x3D;&#x3D;&#x3D;&gt; Fetching release list...Downloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;8&amp;max&#x3D;100 via php streamDownloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;7&amp;max&#x3D;100 via php stream8.0: 8.0.0 ...7.4: 7.4.13, 7.4.12, 7.4.11, 7.4.10, 7.4.9, 7.4.8, 7.4.7, 7.4.6 ...7.3: 7.3.25, 7.3.24, 7.3.23, 7.3.22, 7.3.21, 7.3.20, 7.3.19, 7.3.18 ...7.2: 7.2.34, 7.2.33, 7.2.32, 7.2.31, 7.2.30, 7.2.29, 7.2.28, 7.2.27 ...7.1: 7.1.33, 7.1.32, 7.1.31, 7.1.30, 7.1.29, 7.1.28, 7.1.27, 7.1.26 ...7.0: 7.0.33, 7.0.32, 7.0.31, 7.0.30, 7.0.29, 7.0.28, 7.0.27 ... 想看到更多小版本 12345678910111213141516$ phpbrew known --moreRead local release list (last update: 2020-12-01 03:46:52 UTC).You can run &#96;phpbrew update&#96; or &#96;phpbrew known --update&#96; to get a newer release list.8.0: 8.0.07.4: 7.4.13, 7.4.12, 7.4.11, 7.4.10, 7.4.9, 7.4.8, 7.4.7, 7.4.6, 7.4.5, 7.4.4, 7.4.3, 7.4.2, 7.4.1, 7.4.07.3: 7.3.25, 7.3.24, 7.3.23, 7.3.22, 7.3.21, 7.3.20, 7.3.19, 7.3.18, 7.3.17, 7.3.16, 7.3.15, 7.3.14, 7.3.13, 7.3.12, 7.3.11, 7.3.10, 7.3.9, 7.3.8, 7.3.7, 7.3.6, 7.3.5, 7.3.4, 7.3.3, 7.3.2, 7.3.1, 7.3.07.2: 7.2.34, 7.2.33, 7.2.32, 7.2.31, 7.2.30, 7.2.29, 7.2.28, 7.2.27, 7.2.26, 7.2.25, 7.2.24, 7.2.23, 7.2.22, 7.2.21, 7.2.20, 7.2.19, 7.2.18, 7.2.17, 7.2.16, 7.2.15, 7.2.14, 7.2.13, 7.2.12, 7.2.11, 7.2.10, 7.2.9, 7.2.8, 7.2.7, 7.2.6, 7.2.5, 7.2.4, 7.2.3, 7.2.27.1: 7.1.33, 7.1.32, 7.1.31, 7.1.30, 7.1.29, 7.1.28, 7.1.27, 7.1.26, 7.1.25, 7.1.24, 7.1.23, 7.1.22, 7.1.21, 7.1.20, 7.1.19, 7.1.18, 7.1.17, 7.1.16, 7.1.15, 7.1.147.0: 7.0.33, 7.0.32, 7.0.31, 7.0.30, 7.0.29, 7.0.28, 7.0.27 更新最新版本发行列表 1234567891011$ phpbrew update&#x3D;&#x3D;&#x3D;&gt; Fetching release list...Downloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;8&amp;max&#x3D;100 via php streamDownloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;7&amp;max&#x3D;100 via php stream8.0: 1 releases7.4: 14 releases7.3: 26 releases7.2: 33 releases7.1: 20 releases7.0: 7 releases&#x3D;&#x3D;&#x3D;&gt; Done 获取小于7.0的老版本（官方文档已滞后，还仅仅只把 小于5.4 作为老版本） 注意：不保证能成功构建这些不被PHPBrew官方支持的版本 1$ phpbrew update --old 列举小于7.0的老版本 12345678910111213141516171819$ phpbrew known --old&#x3D;&#x3D;&#x3D;&gt; Fetching release list...Downloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;8&amp;max&#x3D;100 via curl extensionDownloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;7&amp;max&#x3D;100 via curl extensionDownloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;5&amp;max&#x3D;1000 via curl extension8.0: 8.0.0 ...7.4: 7.4.13, 7.4.12, 7.4.11, 7.4.10, 7.4.9, 7.4.8, 7.4.7, 7.4.6 ...7.3: 7.3.25, 7.3.24, 7.3.23, 7.3.22, 7.3.21, 7.3.20, 7.3.19, 7.3.18 ...7.2: 7.2.34, 7.2.33, 7.2.32, 7.2.31, 7.2.30, 7.2.29, 7.2.28, 7.2.27 ...7.1: 7.1.33, 7.1.32, 7.1.31, 7.1.30, 7.1.29, 7.1.28, 7.1.27, 7.1.26 ...7.0: 7.0.33, 7.0.32, 7.0.31, 7.0.30, 7.0.29, 7.0.28, 7.0.27 ...5.6: 5.6.40, 5.6.39, 5.6.38, 5.6.37, 5.6.36, 5.6.35, 5.6.34, 5.6.33 ...5.5: 5.5.38, 5.5.37, 5.5.36, 5.5.35, 5.5.34, 5.5.33, 5.5.32, 5.5.31 ...5.4: 5.4.45, 5.4.44, 5.4.43, 5.4.42, 5.4.41, 5.4.40, 5.4.39, 5.4.38 ...5.3: 5.3.29, 5.3.28, 5.3.27, 5.3.26, 5.3.25, 5.3.24, 5.3.23, 5.3.22 ...5.2: 5.2.17, 5.2.16, 5.2.15, 5.2.14, 5.2.13, 5.2.12, 5.2.11, 5.2.10 ...5.1: 5.1.6, 5.1.5, 5.1.4, 5.1.3, 5.1.2, 5.1.1, 5.1.0 ...5.0: 5.0.5, 5.0.4, 5.0.3, 5.0.2, 5.0.1, 5.0.0 ...PHPBrew needs PHP 5.3 or above to run. build&#x2F;switch to versions below 5.3 at your own risk. 开始构建你自己的PHP用默认variant简单构建并安装PHP： 1$ phpbrew install 7.4.13 +default 这里我们推荐使用 default 设置，它涵盖了大部分广泛使用的variant；如果你需要一个 最小化 安装，那就移除 default，替换成别的variant（经笔者摸索，最小化 为 +opcache -xml）。 通过传递参数 -j 或者 –jobs 进行并行编译： 1$ phpbrew install -j $(nproc) 7.4.13 +default 包含测试： 1$ phpbrew install --test 7.4.13 +default 包含调试信息： 1$ phpbrew -d install --test 7.4.13 +default 安装小于5.3的老版本（笔者实测5.0版本的链接均已不可访问） 1$ phpbrew install --old 5.2.17 安装 next 不稳定版： 1$ phpbrew install next 从GitHub仓库的某tag安装 1$ phpbrew install github:php&#x2F;php-src@PHP-7.0 用 as 给构建安装的PHP取别名，以笔者在前面描述的 最小化 安装举例 1$ phpbrew install 7.4.13 +opcache -xml as 7.4.13-minimal 清理构建目录123$ phpbrew clean 7.4.13-minimal&#x3D;&#x3D;&#x3D;&gt; Running make clean: &#x2F;usr&#x2F;bin&#x2F;make -C &#39;&#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;build&#x2F;7.4.13-minimal&#39; --quiet &#39;clean&#39;Distribution is cleaned up. Woof! VariantsPHPBrew 帮你安排构建参数，你可以简单地指定variant，PHPBrew会自动检测 include 路径并且构建编译选项。 PHPBrew 提供了默认的和虚拟的variant。默认的包含了大部分广泛使用的variants；虚拟的则定义了一组variant，即使用一个虚拟variant可以同时选用多个variant。 查看PHPBrew提供了哪些variant： 1234567891011121314151617181920212223242526272829303132333435$ phpbrew variantsVariants: all, apxs2, bcmath, bz2, calendar, cgi, cli, ctype, curl, dba, debug, dom, dtrace, editline, embed, exif, fileinfo, filter, fpm, ftp, gcov, gd, gettext, gmp, hash, iconv, imap, inifile, inline, intl, ipc, ipv6, json, kerberos, ldap, libgcc, mbregex, mbstring, mcrypt, mhash, mysql, opcache, openssl, pcntl, pcre, pdo, pear, pgsql, phar, phpdbg, posix, readline, session, soap, sockets, sodium, sqlite, static, tidy, tokenizer, wddx, xml, xmlrpc, zip, zlib, ztsVirtual variants: dbs: sqlite, mysql, pgsql, pdo mb: mbstring, mbregex neutral: small: bz2, cli, dom, filter, ipc, json, mbregex, mbstring, pcre, phar, posix, readline, xml, curl, openssl default: bcmath, bz2, calendar, cli, ctype, dom, fileinfo, filter, ipc, json, mbregex, mbstring, mhash, pcntl, pcre, pdo, pear, phar, posix, readline, sockets, tokenizer, xml, curl, openssl, zip everything: dba, ipv6, dom, calendar, wddx, static, inifile, inline, cli, ftp, filter, gcov, zts, json, hash, exif, mbstring, mbregex, libgcc, pdo, posix, embed, sockets, debug, phpdbg, zip, bcmath, fileinfo, ctype, cgi, soap, pcntl, phar, session, tokenizer, opcache, imap, ldap, tidy, kerberos, xmlrpc, fpm, dtrace, pcre, mhash, mcrypt, zlib, curl, readline, editline, gd, intl, sodium, openssl, mysql, sqlite, pgsql, xml, gettext, iconv, bz2, ipc, gmp, pearUsing variants to build PHP: phpbrew install php-5.3.10 +default phpbrew install php-5.3.10 +mysql +pdo phpbrew install php-5.3.10 +mysql +pdo +apxs2 phpbrew install php-5.3.10 +mysql +pdo +apxs2&#x3D;&#x2F;usr&#x2F;bin&#x2F;apxs2 可以看到虚拟variant有：dbs, mb, neutral, small, default, everything （表明上来看 neutral 是最精简的，它不添加任何编译选项，但实际安装过程中还是会启用 xml 和 opcache，而这二者中只有后者无任何第三方依赖。所以真正意义上的 最小化 为 +opcache -xml 或者 +neutral -xml） 需要启用一个variant，直接在variant前加一个 + 号 需要禁用一个variant，直接在variant前加一个 - 号 + 和 - 号可以多个随意组合 指定依赖路径，比如构建pgsql扩展时 1$ phpbrew install 7.4.13 +pdo +pgsql&#x3D;&#x2F;opt&#x2F;local&#x2F;lib&#x2F;postgresql91&#x2F;bin 在 /opt/local/lib/postgresql91/bin 路径下的 pg_config 是构建时需要的 传递额外的configure选项12$ phpbrew install 7.4.13 +mysql +sqlite -- \\ --enable-ftp --apxs2&#x3D;&#x2F;opt&#x2F;local&#x2F;apache2&#x2F;bin&#x2F;apxs 使用与切换使用（临时切换版本） 12$ phpbrew use 7.4.13$ phpbrew use 7.4.13-minimal 切换默认版本 1$ phpbrew switch 7.4.13-minimal 从PHPBrew的版本切换到系统安装的版本 1$ phpbrew off 列举安装的所有php版本1$ phpbrew list 扩展安装器PHPBrew 还能方便的帮助你安装 PHP扩展（无论是PHP源码内自带的亦或是来自于 PECL 的） 如果是PHP源码内自带的，PHPBrew会自动切换到源码目录进而安装扩展；否则会去 PECL http://pecl.php.net去获取扩展源码包 PHPBrew同时会为安装上的扩展创建配置，省去你手写启用扩展的配置文件。配置文件夹位于: $HOME/.phpbrew/php/&#123;php-version&#125;/var/db 安装扩展 - 最简单的方式在你安装任何扩展之前，你应该切换到需要安装扩展的php版本： 1$ phpbrew use 7.4.13-minimal 然后运行 ext install 来安装自己需要的扩展 1234$ phpbrew ext install redis$ phpbrew ext install xdebug$ phpbrew ext install acpu$ phpbrew ext install memcache 安装扩展 - 指定稳定性版本 指定 稳定性标签，可选项有 stable / latest / beta，不指定即默认为 stable，例如：$ phpbrew ext install xdebug latest 指定 扩展版本号，例如：$ phpbrew ext install xdebug 3.0.0 查看扩展的配置选项要查看构建扩展是否有额外的配置选项，使用 ext show 12345678910111213141516$ phpbrew ext show redis Name: redis Source Directory: &#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;build&#x2F;7.4.13&#x2F;ext&#x2F;redis Config: &#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;build&#x2F;7.4.13&#x2F;ext&#x2F;redis&#x2F;config.m4 INI File: &#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13&#x2F;var&#x2F;db&#x2F;redis.ini Extension: Pecl Zend: no Loaded: yes Configure Options: --enable-redis-igbinary[&#x3D;no] enable igbinary serializer support? --enable-redis-lzf[&#x3D;no] enable lzf compression support? --enable-redis-zstd[&#x3D;no] enable zstd compression support? 为构建扩展添加额外配置选项1$ phpbrew ext install redis -- --enable-redis-lzf&#x3D;yes 从Github安装扩展特殊的前缀 github: 则告诉PHPBrew要去 php-memcached-dev/phpmemcached 的 php7 分支拉取代码进行构建 1$ phpbrew ext install github:php-memcached-dev&#x2F;php-memcached php7 -- --disable-memcached-sasl 指定下载器进行安装扩展目前，PHPBrew有4个下载器实现： php_curl 内置的 php curl扩展，为默认下载器 php_stream 内置的 php steam封装 curl wget 指定 curl 作为下载器： 1$ phpbrew ext install --downloader curl redis 如果选用的下载器支持 User-Agent 和 Proxy 配置： 1$ phpbrew ext install --downloader php_curl --http-proxy&#x3D;... --http-proxy-auth&#x3D;... apcu 启用扩展笔者亲测，通过 ext install 安装的扩展，安装完即为启用状态。 另外也可以通过 PECL 安装扩展并且手动启用： 12$ pecl install mongo$ phpbrew ext enable mongo ext enable 指令帮你创建配置文件 {current php base}/var/db/{extension name}.ini 用以启用扩展 为当前php版本配置 php.ini12$ export EDITOR&#x3D;vim # 该行为可选项，指定你常用的编辑器$ phpbrew config 更新 PHPBrew运行 self-update 指令将会从Github的master分支下载最新版本的二进制文件替换自身（即本文开头的存放位置/usr/local/bin/phpbrew） 相关的目录已安装的php位于 $HOME/.phpbrew/php，以 7.4.13-minimal 举例，为 $HOME/.phpbrew/php/7.4.13-minimal/bin/php 配置文件为 $HOME/.phpbrew/php/7.4.13-minimal/etc/php.ini 扩展的配置文件位于 $HOME/.phpbrew/php/7.4.13-minimal/var/db目录下： 123$HOME&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13-minimal&#x2F;var&#x2F;db&#x2F;memcache.ini$HOME&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13-minimal&#x2F;var&#x2F;db&#x2F;xdebug.ini$HOME&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13-minimal&#x2F;var&#x2F;db&#x2F;redis.ini 在各目录之间切换的快捷命令官方文档里这部分涉及的指令，比如 build-dir / dist-dir / etc-dir / var-dir 已亲测全部阵亡 PHP fpmPHPBrew同时也为 php-fpm 提供了管理指令（前提是在构建的时候得加上 +fpm variant） 启动/停止/重启 php-fpm： 123$ phpbrew fpm start$ phpbrew fpm stop $ phpbrew fpm restart 显示 php-fpm 模块： 1234567891011$ phpbrew fpm module[PHP Modules]bz2cgi-fcgiCorectypecurl...[Zend Modules]Xdebug 测试 php-fpm 配置是否正确： 12$ phpbrew fpm test[01-Dec-2020 18:28:04] NOTICE: configuration file &#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13&#x2F;etc&#x2F;php-fpm.conf test is successful 编辑 php-fpm 配置： 12$ export EDITOR&#x3D;vim # 该行为可选项，指定你常用的编辑器$ phpbrew fpm config 已安装的 php-fpm 位于 $HOME/.phpbrew/php/&#123;php-version&#125;/sbin 下 相应的 php-fpm.conf 位于 $HOME/.phpbrew/php/&#123;php-version&#125;/etc/php-fpm.conf.default, 你可以将默认配置文件拷贝到需要的位置进行使用，比如 $ cp -v ~/.phpbrew/php/&#123;php-version&#125;/etc/php-fpm.conf.default ~/.phpbrew/php/&#123;php-version&#125;/etc/php-fpm.conf $ php-fpm --php-ini ~/.phpbrew/php/&#123;php-version&#125;/etc/php.ini --fpm-config ~/.phpbrew/php/&#123;php-version&#125;/etc/php-fpm.conf 安装扩展应用通过 app get 指令来安装例如 composer 和 phpunit 这样的 app，笔者亲测该指令也已阵亡 结尾以上便是笔者结合 PHPBrew 官方文档给大家梳理的使用指南，写该文时每条指令笔者都亲自测试过，所以发现了官方文档里有很多地方都 已过时 或 已更新。对于前者，笔者用横线给划掉了；对于后者，笔者直接进行了修正。 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"dev","slug":"dev","permalink":"https://blog.chaosjohn.com/tags/dev/"},{"name":"package manager","slug":"package-manager","permalink":"https://blog.chaosjohn.com/tags/package-manager/"}]},{"title":"端口转发(篇一) - rinetd","slug":"Port-Forwarding-1","date":"2020-11-30T09:09:13.000Z","updated":"2020-11-30T15:19:04.634Z","comments":true,"path":"Port-Forwarding-1.html","link":"","permalink":"https://blog.chaosjohn.com/Port-Forwarding-1.html","excerpt":"","text":"前言笔者准备写一个 端口转发 系列文章，涉及计多个工具和命令。 本文为篇一，介绍一个大家常用的工具，rinetd。 简介A: 端口转发英文：Port forwarding 将一台 主机A 的 端口x 转发到另一台 主机B 的 端口y 并由 主机B 提供转发的网络服务。 即通过访问 主机B:端口y 来访问部署在 主机A:端口x 上的服务。 简介B: rinetd项目主页 / Github rinetd是为在一个Unix和Linux操作系统中为重定向传输控制协议(TCP)连接的一个工具。 rinetd是单一过程的服务器，它处理任何数量的连接到在配置文件etc/rinetd中指定的地址/端口对。 尽管rinetd使用非闭锁I/O运行作为一个单一过程，它可能重定向很多连接而不对这台机器增加额外的负担。 场景最早接触到这个工具，是几年前购买了阿里云的Redis实例，当初该服务未推出公网连接地址，只能通过内网访问，即只在同一个区域的VPC内可达，在当初的业务环境下，只能从阿里云的ECS访问Redis实例。 这就很恼怒了，在笔者本地的开发环境，也要连接改Redis实例，咋办哩。 于是就在阿里云在线文档里找到了这个工具，我还依稀记得那篇文档里，介绍的是如何在CentOS下载rinetd源码（还提供了tar.gz的链接地址），然后编译安装它。（不过伴随着阿里云Redis实例开始支持公网连接后，该文档已经消失在了历史长河里了。） 安装 编译安装（适用于任何Linux环境，但个人不推荐，因为还得手动配置开机自启） 123456$ curl -LO &#39;http:&#x2F;&#x2F;www.rinetd.com&#x2F;download&#x2F;rinetd.tar.gz&#39;$ tar xvzf rinetd.tar.gz$ cd rinetd$ sed -i &#39;s&#x2F;65536&#x2F;65535&#x2F;g&#39; rinetd.c （修改端口范围，否则会报错）$ make$ sudo make install （提示：官方下载的源码包无法在macOS下完成编译，报错 error: implicit declaration of function &#39;inet_addr&#39; is invalid in C99） 在 macOS 上借助 Homebrew 安装 1$ brew install rinetd 在 Debian / Ubuntu 上借助 apt 安装 12$ sudo apt update$ sudo apt install rinetd 在 RHEL / CentOS 上借助 yum 安装 官方源中无rinetd，所以需要先安装三方源 12345678$ sudo vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nux-misc.repo[nux-misc]name&#x3D;Nux Miscbaseurl&#x3D;http:&#x2F;&#x2F;li.nux.ro&#x2F;download&#x2F;nux&#x2F;misc&#x2F;el6&#x2F;x86_64&#x2F;enabled&#x3D;0gpgcheck&#x3D;1gpgkey&#x3D;http:&#x2F;&#x2F;li.nux.ro&#x2F;download&#x2F;nux&#x2F;RPM-GPG-KEY-nux.ro 然后再安装rinetd 1$ sudo yum --enablerepo&#x3D;nux-misc install rinetd 配置配置文件路径为 /etc/rinetd.conf，并附上那台转发Redis的配置内容 1234567891011121314151617181920212223242526## this is the configuration file for rinetd, the internet redirection server## you may specify global allow and deny rules here# only ip addresses are matched, hostnames cannot be specified here# the wildcards you may use are * and ?## allow 192.168.2.*# deny 192.168.2.1?## forwarding rules come here## you may specify allow and deny rules after a specific forwarding rule# to apply to only that forwarding rule## bindadress bindport connectaddress connectport0.0.0.0 6379 r-ly25ac35fxxxxx.redis.rds.aliyuncs.com 6379# logging informationlogfile &#x2F;var&#x2F;log&#x2F;rinetd.log# uncomment the following line if you want web-server style logfile format# logcommon allow 和 deny 是配置 允许和阻止 的 IP地址/IP段 转发规则一行一个，可配置多行 bindadress bindport connectaddress connectport，如示例里配置为：监听本网卡地址的6379端口号，并且转发到VPC内网Redis实例的6379端口号。 运行和自启 如果是通过源码编译安装的，命令行直接执行 rinetd；自启的话，得手动编写 Systemd 的Unit文件来管理或者通过 Supervisor 来管理。 如果是 apt 或 yum 安装的，并且init程序是 Systemd 启动服务: $ sudo systemctl start rinetd 停止服务: $ sudo systemctl stop rinetd 重启服务: $ sudo systemctl restart rinetd 开机自启: $ sudo systemctl enable rinetd 禁用自启: $ sudo systemctl disable rinetd 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"network","slug":"network","permalink":"https://blog.chaosjohn.com/tags/network/"},{"name":"tool","slug":"tool","permalink":"https://blog.chaosjohn.com/tags/tool/"},{"name":"port-forwarding","slug":"port-forwarding","permalink":"https://blog.chaosjohn.com/tags/port-forwarding/"}]},{"title":"清理 APFS 快照的shell脚本","slug":"Clean-APFS-Snapshots","date":"2020-11-29T15:26:03.000Z","updated":"2020-11-29T16:01:35.192Z","comments":true,"path":"Clean-APFS-Snapshots.html","link":"","permalink":"https://blog.chaosjohn.com/Clean-APFS-Snapshots.html","excerpt":"","text":"背景macOS 从 10.13 High Sierra开始，引入了 APFS(Apple File System) 替代原先的 HFS+ 作为默认磁盘格式。 笔者觉得最大的特色在于 写时拷贝(Copy-on-Write) 和 快照(Snapshots)。对于前者，以后有机会笔者再写文阐述，本文主要针对后者。 快照的引入，可以方便并且快速地恢复到过去的某个时间节点，它与 时间机器(Time Machine) 配合起来，可以极大程度的保证数据安全。 但快照也导致一个不良后果，即占据了大量的磁盘空间。比如明明没使用很多文件，怎么磁盘空间耗去大半。 查看快照这里利用到 tmutil 这个命令，通过查询 man 手册，发现它全称为 Time Machine utility，即原用于时间机器。 $ tmutil listlocalsnapshots / 123456789101112131415161718192021222324Snapshots for volume group containing disk &#x2F;:com.apple.TimeMachine.2020-11-29-004329.localcom.apple.TimeMachine.2020-11-29-014637.localcom.apple.TimeMachine.2020-11-29-024241.localcom.apple.TimeMachine.2020-11-29-034330.localcom.apple.TimeMachine.2020-11-29-044145.localcom.apple.TimeMachine.2020-11-29-054542.localcom.apple.TimeMachine.2020-11-29-064456.localcom.apple.TimeMachine.2020-11-29-074846.localcom.apple.TimeMachine.2020-11-29-084356.localcom.apple.TimeMachine.2020-11-29-094633.localcom.apple.TimeMachine.2020-11-29-104339.localcom.apple.TimeMachine.2020-11-29-114752.localcom.apple.TimeMachine.2020-11-29-134250.localcom.apple.TimeMachine.2020-11-29-144214.localcom.apple.TimeMachine.2020-11-29-154417.localcom.apple.TimeMachine.2020-11-29-164352.localcom.apple.TimeMachine.2020-11-29-174500.localcom.apple.TimeMachine.2020-11-29-184606.localcom.apple.TimeMachine.2020-11-29-194225.localcom.apple.TimeMachine.2020-11-29-204725.localcom.apple.TimeMachine.2020-11-29-214338.localcom.apple.TimeMachine.2020-11-29-224417.localcom.apple.TimeMachine.2020-11-29-234647.local 通过 df -th 查看磁盘剩余 153GB 清理快照这里祭出一行shell脚本 $ for snapshot in $(tmutil listlocalsnapshots / | awk -F. ‘{print $4}’); do tmutil deletelocalsnapshots $snapshot; done 1234567891011121314151617181920212223Deleted local snapshot &#39;2020-11-29-004329&#39;Deleted local snapshot &#39;2020-11-29-014637&#39;Deleted local snapshot &#39;2020-11-29-024241&#39;Deleted local snapshot &#39;2020-11-29-034330&#39;Deleted local snapshot &#39;2020-11-29-044145&#39;Deleted local snapshot &#39;2020-11-29-054542&#39;Deleted local snapshot &#39;2020-11-29-064456&#39;Deleted local snapshot &#39;2020-11-29-074846&#39;Deleted local snapshot &#39;2020-11-29-084356&#39;Deleted local snapshot &#39;2020-11-29-094633&#39;Deleted local snapshot &#39;2020-11-29-104339&#39;Deleted local snapshot &#39;2020-11-29-114752&#39;Deleted local snapshot &#39;2020-11-29-134250&#39;Deleted local snapshot &#39;2020-11-29-144214&#39;Deleted local snapshot &#39;2020-11-29-154417&#39;Deleted local snapshot &#39;2020-11-29-164352&#39;Deleted local snapshot &#39;2020-11-29-174500&#39;Deleted local snapshot &#39;2020-11-29-184606&#39;Deleted local snapshot &#39;2020-11-29-194225&#39;Deleted local snapshot &#39;2020-11-29-204725&#39;Deleted local snapshot &#39;2020-11-29-214338&#39;Deleted local snapshot &#39;2020-11-29-224417&#39;Deleted local snapshot &#39;2020-11-29-234647&#39; 再次通过 df -th 查看磁盘剩余 159GB，释放出 6GB 空间 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"APFS","slug":"APFS","permalink":"https://blog.chaosjohn.com/tags/APFS/"},{"name":"shell","slug":"shell","permalink":"https://blog.chaosjohn.com/tags/shell/"}]},{"title":"IPv6在虚拟机通过无线网卡桥接的网络下无法使用(VMware WorkStation)","slug":"IPv6-not-working-from-bridged-wireless","date":"2020-11-28T10:19:22.000Z","updated":"2020-11-28T13:35:25.435Z","comments":true,"path":"IPv6-not-working-from-bridged-wireless.html","link":"","permalink":"https://blog.chaosjohn.com/IPv6-not-working-from-bridged-wireless.html","excerpt":"","text":"背景今年年中的时候，在油管上看到 悟空大大 关于 Minisforum GK41 的视频，心里痒痒，于是也入手了一个。主要具体参数为： CPU: Intel® Celeron® Processor J4125 内存: LPDDR4 8GB (On Board) 网络: 双千兆螃蟹卡 + 802.11ac双频Wifi 买之前想的很美妙，买它！当软路由！就奔着它双网口且不到日常使用5~6W的超低功耗！ 结果买回来就开始纠结了，用它当软路由是不是太浪费了？毕竟128GB的M.2固态，只拿来跑OpenWRT，很难把空间占满啊；内部也没有SATA接口，无法把废弃硬盘利用起来；也不支持从TF卡槽启动，手里一堆TF卡也无用。 机子买来就预装了正版Windows10，想着好久没有用Windows了，那就顺便玩玩吧。于是手就不听使唤的把 VMware WorkStation给安装上了，又不听使唤的装了个 Manjaro Linux 虚拟机。 问题：客户机IPv6无法使用网络拓扑结构： GK41主机通过无线网卡连接Wi-Fi 虚拟客户机采用桥接模式（非NAT模式），桥接无线网卡加入网络 至此，虚拟客户机也从上级路由器获得IPv4地址，与GK41主机处于同一个局域网。 但是无法访问IPv6网络（由于这台GK41已经转手卖掉了很久，所以记不清是无法从上级路由器获取IPv6地址还是分配到了IPv6地址但无法联通网络）。因笔者将GK41放在公司，脱离了IPv6就意味着笔者无法便捷地从家里访问到这台虚拟客户机。 解决过程（最后发现无解）尝试：插上网线，把桥接模式从无线网卡改为有线网卡，IPv6奇迹般的有了！所以问题肯定出在了 无线桥接 上。 于是笔者各种查资料爬帖，各种折腾，最后发现了2008年的一篇帖子IPv6+Bridged+Wireless。 文中描述 This is a known issue, IPv6 is not expected to work over a wireless bridge. 在帖子发布的时候，这个bug（编号#26078）覆盖了VMware的全线产品，包括WorkStation/Player/Fusion。另参考 （实测 VMware Fusion 在很早以前就已经修复该bug，因为笔者有一台2009年的MacBook，还跑着 Mac OS X 10.7 Lion，运行着 VMware Fusion 6.0.6版本，而其内的虚拟客户机的IPv6是正常的，包括后来的高版本Fusion下的虚机IPv6都好使。所以很明显，只是WorkStation上这个bug依旧存在） 至此，放弃折腾，Over。(如何有网友发现解决该问题的办法，不吝赐教哈，评论区或者加我微信 Chaos_John )","categories":[],"tags":[{"name":"Virtualization","slug":"Virtualization","permalink":"https://blog.chaosjohn.com/tags/Virtualization/"},{"name":"IPv6","slug":"IPv6","permalink":"https://blog.chaosjohn.com/tags/IPv6/"},{"name":"network","slug":"network","permalink":"https://blog.chaosjohn.com/tags/network/"},{"name":"VMware","slug":"VMware","permalink":"https://blog.chaosjohn.com/tags/VMware/"}]},{"title":"iCloud同步排除文件/目录","slug":"iCloud-Sync-Exclusion","date":"2020-11-27T06:49:16.000Z","updated":"2020-11-27T08:00:22.464Z","comments":true,"path":"iCloud-Sync-Exclusion.html","link":"","permalink":"https://blog.chaosjohn.com/iCloud-Sync-Exclusion.html","excerpt":"","text":"前言苹果的iCloud服务，是笔者离不开苹果生态的一大重要原因。 但是苹果鸡贼的很，免费用户5GB存储空间轻轻松松就存满了，所以早年刚出付费升级容量的时候，我就购买了最低的付费容量，20GB/¥6/月。虽然不多，但是备份iPhone设备（特别是相册），也是够用的。不过后来苹果良心发现，加量不加价，自动给变更成了50GB。 自从 OS X 10.10 Yosemite 开始，iCloud开始可以用于在mac上进行文件存储，又自从 iOS 11 开始，iCloud Drive被集成到了iPhone/iPad上，任意设备都可访问和编辑存储在iCloud内的文件，至此，文件跨设备共享和同步，就成了苹果生态的一大杀手锏。iCloud发展历史 请移步 维基百科 以至于当50GB也不够用的时候，我毫不纠结的升级到了 200GB/¥20/月 的套餐（还支持家庭组共享容量）。 iCloud 储存空间方案和定价 痛点问题为了方便在多台mac设备之间切换却又保持工作的连贯，iCloud Drive还被很多人用作同步工程目录。 举个例子，当前端工程放在iCloud内，光一个 node_modules 目录，就能占据你几百MB甚至上GB的空间，何其浪费。 解决办法将类似 node_modules 的目录排除在外。一般来说，具备同步功能的工具（比如Syncthing）都会有 排除目录/文件 的设置项，但是iCloud偏偏没有。社区内很多用户向苹果提了改进意见，但是苹果官方就是“不听不听，王八念经”的态度。 但也不能说苹果没有提供排除文件/目录的方案，只不过方案比较恶心罢了。很简单，在目录/文件夹尾部加上 .nosync 后缀，就不会被iCloud同步了。 喵喵喵？？？需要我改文件名？？？这叫什么事啊摔！！！ 没辙，这个时候只能用“软链接”来实现了： mv node_modules node_module.nosync 重命名尾部加 .nosync ln -sf node_modules.nosync node_modules，将重命名后的目录软链接到 node_modules，这样 npm 还能通过 node_modules 目录管理第三方库 当然，也有开源工具来帮你更高效地做这件事，移步HaoChuan9421/nosync-icloud 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"iCloud","slug":"iCloud","permalink":"https://blog.chaosjohn.com/tags/iCloud/"}]},{"title":"Homebrew更新相关小技巧","slug":"Homebrew-upgrade","date":"2020-11-26T07:22:22.000Z","updated":"2020-11-26T09:17:35.232Z","comments":true,"path":"Homebrew-upgrade.html","link":"","permalink":"https://blog.chaosjohn.com/Homebrew-upgrade.html","excerpt":"","text":"前言笔者在四年前曾写过一文HomeBrew – OSX下的最强软件包管理器，篇中详细介绍了HomeBrew以及Cask的使用。 多年过去了，Homebrew依旧非常流行，但内在也发生了很多变化，比如Cask原先作为第三方Tap的存在，现已整合到Homebrew内，在未安装Cask的环境里，执行 brew cask install $&#123;app&#125;，Homebrew则会自动安装Cask。 同时，在Homebrew的日常使用中，笔者也遇到了很多问题，本文就着重于“踩坑”和“填坑”。 “这些年遇到的坑”Homebrew自动更新brew 提供了 update 命令，但是你执行 install 或 upgrade 时，都会强制性先 update，浪费宝贵的时间。 解决： brew命令前加上变量HOMEBREW_NO_AUTO_UPDATE=1，变为 $ HOMEBREW_NO_AUTO_UPDATE=1 brew install … 或使用alias别名，在.bashrc或.zshrc中新增一行 alias brew=&quot;HOMEBREW_NO_AUTO_UPDATE=1 brew&quot; 或导出环境变量，在.bashrc或.zshrc中新增一行 export HOMEBREW_NO_AUTO_UPDATE=1，笔者推荐这种方法 或者使用 Homebrew/aliases，执行 brew alias install_no_autoupdate=&#39;!HOMEBREW_NO_AUTO_UPDATE=1 brew install&#39;（install_no_autoupdate 名字任意更换），以后要执行无预更新的 brew install $&#123;formula&#125; 操作，都改为 brew install_no_autoupdate $&#123;formula&#125; Cask 安装的应用，和 App Store 安装的应用，都混在了一起因为双方都把应用安装到了 /Applications 目录下，所以导致 分不清应用到底是Cask安装的，还是App Store里安装的 如果Cask和App Store安装同一款应用，则后安装或更新的应用，就会覆盖掉先前存在的版本 解决：export HOMEBREW_CASK_OPTS=&quot;--appdir=~/Applications/_&quot;，这样Cask会自动将应用都安装到用户目录下的 Applications/_/ 里。 这里我想介绍一下我在mac下的应用管理，仅供参考： App Store安装的应用，都位于 /Applications/ 下 Cask安装的应用，都位于 ~/Applications/_/ 下 网络上搜罗来的破解应用，都位于 ~/Applications/#/ 下 JetBrains公司的IDE，都用 JetBrains Toolbox 进行安装管理（当然Toolbox本身是用Cask进行安装的） 其他开源/免费的应用，都位于 ~/Applications/ 下 Cask 批量更新应用在前文HomeBrew – OSX下的最强软件包管理器中笔者曾给出过一行shell脚本用来批量更新Cask的应用，但是这么多年过去了，这行脚本笔者不再推荐使用。解决：brew tap buo/cask-upgrade，项目链接，安装完之后， 执行: brew cu，更新所有“存在更新版本”的应用 执行: brew cu $&#123;app&#125;，更新特定app 选项: -a, --all，包含标记了 auto-update 的应用；-f, --force，包含当前版本号为 latest 的应用；-y, --yes，对所有询问是否确认更新，自动应答 yes 因国内网络环境导致brew速度慢这里的慢包含两方面：brew update 慢 &amp; brew install 慢 解决方案A: 换源策略 brew update 慢，参考清华镜像源指南 brew install 慢，参考清华镜像源指南 解决方案B: 代理策略, export all_proxy=socks5://$&#123;host&#125;:$&#123;port&#125;，替换自己代理主机地址和端口即可 Error: SHA256 mismatch / Error: Checksum mismatch前者是 brew 后者是 cask，错误原因，仓库里记载的校验值和实际下载下载的文件校验值不一致 解决: 执行 rm -rf ~/Library/Caches/Homebrew 将本地缓存目录删除后重试，有概率能解决问题，适用于软件发行者修改应用后缺没有更改版本号就发行出去的情况。若未解决，针对于 brew，编辑 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/$&#123;formula&#125;.rb，针对于 cask，编辑 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask/Casks/$&#123;app&#125;.rb，将 sha256修改为实际校验值，保存，再次执行先前操作，大概率能成功。切记两点主意事项： 需禁用brew的自动更新，否则前脚刚改完校验值，后脚自动更新就把校验值改回来了 更改校验值后不要关闭编辑器，等安装/更新应用成功后，立即撤销更改，再关闭编辑器，因为brew和cask的仓库是用git管理的，更改仓库文件对后续的更新会造成冲突。如果发生冲突了，也别担心，到仓库根目录执行 git reset --hard恢复原样。brew 的仓库目录位于 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/；cask 的仓库目录位于 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask/ 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://blog.chaosjohn.com/tags/Homebrew/"}]},{"title":"禁用macOS更新提醒角标","slug":"Disable-Update-Badge-of-macOS","date":"2020-11-26T01:23:06.000Z","updated":"2020-11-26T06:51:19.551Z","comments":true,"path":"Disable-Update-Badge-of-macOS.html","link":"","permalink":"https://blog.chaosjohn.com/Disable-Update-Badge-of-macOS.html","excerpt":"","text":"近日来，苹果电脑的操作系统 macOS Catalina 接近了生命周期的尾声，新的操作系统 Big Sur 于2020年11月12日已经发布（很有意思的是正式版的首个版本号为11.0.1，而11.0.0并未对外发布，只预装在Apple M1的三台ARM新机上，详见下图，来源于维基百科） 笔者是Mac死忠粉，自 Mac OS X 10.7 Lion 开始用，经历过系统升级还需付费购买的年代（还记得当时是花了128元升级到了 OS X 10.8 Mountain Lion ），跨到开始免费的 OS X 10.9 Mavericks ，直至后来开始抛去 OS X 命名的 macOS Sierra ，然后到 macOS High Sierra ，只要释出第一个版本，笔者就会更新尝鲜。无奈，很明显的感觉到苹果在软件方面的“做工”越来越糙了，尝鲜用户慢慢沦为了”实验小白鼠”以及”bug反馈器”，所以后来的 macOS Majave 和 macOS Catalina ，我放弃了尝鲜，都等到x.4版本释出才决定更新，才堪堪感觉“可以用了”。 macOS Big Sur 这不刚出就被人笑成 Bug Sur ，笔者毅然决然不更它。 可是问题来了，升级提醒小红点真是逼死我了！！！还不是一处！ 系统左上角苹果标🍎，点击下拉菜单，在 系统偏好设置(System Preferences) 处提醒有更新 如果把 系统偏好设置 锁定在Dock栏的话，小红点+1 在 系统偏好设置 内的 软件更新(Software Update) 上，小红点+2 解决策略- 系统版本 小于 10.15.5 or 等于 10.15.6（是的，就是这么奇怪，该策略在10.15.5中被弃用了，但在10.15.6中又放出来了，之后又去掉了，参考） 关闭 系统偏好设置 打开 终端(Terminal) 执行 sudo softwareupdate --ignore &quot;macOS Big Sur&quot;。如果处于 Mojave 想阻止升级到 Catalina, 把命令中的 Big Sur 改成 Catalina即可。 （如果改变主意想接收更新了，执行 sudo softwareupdate --reset-ignored即可恢复） - 系统版本 等于 10.15.5 or 大于 10.15.6 执行: defaults write com.apple.systempreferences AttentionPrefBundleIDs 0 &amp;&amp; killall Dock，小红点就消失了，不再提示升级了 恢复: defaults write com.apple.systempreferences AttentionPrefBundleIDs 1 &amp;&amp; killall Dock 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Skills","slug":"Skills","permalink":"https://blog.chaosjohn.com/tags/Skills/"},{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"}]},{"title":"于2020年末的回归","slug":"Comeback-in-2020","date":"2020-11-25T07:07:01.000Z","updated":"2020-11-25T08:38:45.000Z","comments":true,"path":"Comeback-in-2020.html","link":"","permalink":"https://blog.chaosjohn.com/Comeback-in-2020.html","excerpt":"","text":"是的，我回来了。 距写上一篇文章已经过去3年多了，很汗颜，虽然文章本来就不多。 建站之初，想好好经营这个博客，毕竟我是一个非常乐于分享的技术宅，我想把我学会的，我踩坑的，我创造的，都通过这个博客展示出来。 虽然找借口很不耻，但我不得不解释一下，为啥挺好的抱负却被我荒废了三年之久。 次要原因：工作不得志，职场不称心 主要原因：生活了无希望，前女友掏空我所有的精力，即使把所有的心思都花上，得来的是无休止的挑刺和吵闹。多次分手无果(懂的人自然懂)，认命了，就像一眼看到了人生的终点，对感情和生活完全丧失信心，进而在自己热爱的工作和行业上失去了奋斗的动力。 万幸的是，我最后终于摆脱了前任，并且走出了阴影。更加幸运的是，半年前，我遇到了我的小可爱，她的出现，照亮了我的天空。 我满血复活了！！！ 所以，我回来了！","categories":[],"tags":[]},{"title":"Hexo YAMLException: can not read a block mapping entry","slug":"Hexo-YAMLException-can-not-read-a-block-mapping-entry","date":"2017-10-09T07:28:03.000Z","updated":"2020-11-26T01:11:15.000Z","comments":true,"path":"Hexo-YAMLException-can-not-read-a-block-mapping-entry.html","link":"","permalink":"https://blog.chaosjohn.com/Hexo-YAMLException-can-not-read-a-block-mapping-entry.html","excerpt":"","text":"问题好久没写博客，刚刚写了一篇Nginx反向代理获取真实客户端IP，然后执行hexo d -g是报了错：YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1: 查错 先来看看刚刚写的Markdown文件 很明显，第四行只是一个分隔符，怎么可能出问题 谷歌一下错误，发现问题所在，其实是第三行的错误，tags:后面没有跟空格，yaml处理出错。参考 捐赠最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.chaosjohn.com/tags/hexo/"}]},{"title":"Nginx反向代理获取真实客户端IP","slug":"Nginx-Real-Client-IP","date":"2017-10-09T02:51:57.000Z","updated":"2020-11-25T09:44:24.000Z","comments":true,"path":"Nginx-Real-Client-IP.html","link":"","permalink":"https://blog.chaosjohn.com/Nginx-Real-Client-IP.html","excerpt":"","text":"起因 此前做了一个小项目，php实现，ip.chaosjohn.com, 可以用命令行来获取当前客户端ip地址，效果如下： 之前是用CaddyServer来运行这个服务，最近把其从CaddyServer迁移到nginx，很顺利的迁移成功。以学习为目的，我在该服务器上用另外一个地址ip.vultr-01.coodiin.com（以下称“反代端”）反向代理到ip.chaosjohn.com（以下称“后端”），却出现问题了，ip读取不正确，显示的是服务器的IP。Nginx配置如下： 问题分析 出现这样的情况的原因是因为，在反向代理的过程中，对于后端而言，反代端就是客户端。 解决 要解决这个问题，则需要把真实的客户端地址告诉后端。那反代端和后端怎么沟通真实的IP地址呢？一个说另一个得听吧，两边都要设置。 反代端 proxy_set_header X-Real-IP $remote_addr; # 设置X-Real-IP为真实来源请求的IP地址 proxy_bind 127.0.0.1; # 规定代理请求的出口地址 后端 set_real_ip_from 127.0.0.1/32; # 只有从这个地址来的请求才会设置真实IP，才会应用X-Real-IP这个header 最后的代码 4. 结语下次打算记录一下php的配置，包含Nginx和CaddyServer。最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.chaosjohn.com/tags/Nginx/"}]},{"title":"破解Mac菜单栏神器 -- Bartender2","slug":"Crack-Bartender2","date":"2016-11-04T06:59:31.000Z","updated":"2020-11-26T01:11:13.000Z","comments":true,"path":"Crack-Bartender2.html","link":"","permalink":"https://blog.chaosjohn.com/Crack-Bartender2.html","excerpt":"","text":"题外话真的好久好久没有更新blog了，上篇博客还是今年5月30号。虽然好几次想更两篇，但是。。。懒癌晚期。。。哈哈哈，废话不多说，进入正文。 软件介绍Bartender是一款管理mac菜单栏图标的软件，笔者的mac装了很多很多的应用，很多都会在菜单栏里停驻一个图标，然后顶部的菜单栏悲剧的挤满了。。。用Windows的童鞋都知道，在桌面任务栏右下角都会有一箭头，收起时只显示几个常驻的图标，点击后其他隐藏的图标才会出现。一直搞不明白为什么苹果原生不能增加一个这样的功能呢？应该也不是什么难事呀！Bartender实现的就是这个功能。关于Bartender的详细介绍移步少数派 破解的缘由 笔者其实很愿意为软件花钱（前提是在承受范围内哈哈哈），自打大四进入工作以来，在各类软件&amp;服务上花的钱也有一两千了。比如，Bartender第一代，我就花了$15。然后就一直使用到今年，一直相安无事，直到Bartender出了第二代，优化了界面显示以及加了些小功能，但是都没戳中我痛点，所以就一直没有去改用Bartender2。 但是，9月下旬mac更新了操作系统macOS Sierra，升级完很悲剧的发现，Bartender1已经不兼容改操作系统了，而且显然，作者把重心放在了Bartender2上，估计也不会更新Bartender1了。不得已，只好卸载了1安装上了2。结果发现，1的序列号不能再2上使用，得重新购买($15)或者从1升级到2($7.5)。。。天杀的！！！ 还好有4个星期的试用期，就先用着了。。。但是用着一个会到期的服务，那感觉，就像头上悬着把刀，很不是滋味。。。于是我就开始思考：它是怎么计算试用时间的？ 一番捣鼓后，试用时间被我成功重置，但是不知道这个漏洞会不会被封堵掉，所以直到今天被我再次重置后(期间Bartender2已经升级了好几个版本)，我才确定了我的破解方法的可行性。 破解过程 假设Bartender2试用时间已过期 关闭Bartender2，打开AppCleaner，找到Bartender2那项，点击它，会弹出一个窗口，里面会罗列出与该应用相关的所有配置文件等等。 经猜测锁定”com.surteesstudio.Bartender.plist”，打开翻到最后，果然看到“trialStart”这样的字样，哈哈哈。 用编辑器打开(笔者用的XCode，因为上次直接用Vim编辑保存后Bartender不能识别），把”trialStart”和”trialStart2”改成当前日期的前两天. 大功告成 结语最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Crack","slug":"Crack","permalink":"https://blog.chaosjohn.com/tags/Crack/"},{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"}]},{"title":"解决“Gradle -- Could not find tools.jar”","slug":"Gradle-Could-not-find-tools-jar","date":"2016-05-30T06:48:44.000Z","updated":"2020-11-26T01:11:15.000Z","comments":true,"path":"Gradle-Could-not-find-tools-jar.html","link":"","permalink":"https://blog.chaosjohn.com/Gradle-Could-not-find-tools-jar.html","excerpt":"","text":"错误出现的环境 CentOS 7 x86_64 已通过sudo yum install java-1.8.0-openjdk安装OpenJDK8 部署完成的Spring-Boot项目，执行./gradlew bootRun 报错`Could not find tools.jar 该项目在其他的机器上均未出现该问题，包括OSX、Ubuntu和另一台CentOS 解决方案 经StackOverFlow搜索，发现Gradle does not find tools.jar和Correct way of referencing tools.jar in a cross-platform way两篇，主要是通过改build.gradle，强制加入tools的搜寻路径来解决问题。目测有效，但是因为在其他机子上都正常运行不报错，所以放弃该方案。 突然想起来在很多情况下报错都是因为没有安装dev包（或devel包），比如pip安装模块却没有安装python-dev等等。就寻思着，OpenJDK会不会也要安装dev组件呢？ 键入sudo yum search openjdk | grep -i dev进行搜索，果然有java-1.8.0-openjdk-devel sudo yum install java-1.8.0-openjdk-devel，再次./gradlew bootRun，成功运行不报错 结语开发过程中出现问题了，不仅要勤搜索，还要勤动脑思考。最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.chaosjohn.com/tags/Java/"},{"name":"Gradle","slug":"Gradle","permalink":"https://blog.chaosjohn.com/tags/Gradle/"},{"name":"Error","slug":"Error","permalink":"https://blog.chaosjohn.com/tags/Error/"}]},{"title":"Mosh(Mobile Shell) -- 增强版SSH","slug":"Mosh-Imporved-SSH","date":"2016-05-30T06:25:15.000Z","updated":"2020-11-25T03:21:45.000Z","comments":true,"path":"Mosh-Imporved-SSH.html","link":"","permalink":"https://blog.chaosjohn.com/Mosh-Imporved-SSH.html","excerpt":"","text":"开场白 Mosh，是Mobile Shell的缩写(Mo+Sh)，是一个增强版的SSH，或者套用官方的话来说，Mosh is a replacement for SSH。 SSH相信大家应该都不陌生，我们都用它来进行远程登录Unix-like的操作系统，比如运行着Linux的云服务器。 SSH有一个很大的弊病，那就是连接会断。比如新建了一个SSH会话，然后突然网断了，SSH就断开连接终止了。 Mosh就是用来解决这个问题的，它可以“漫游”。网断了，重连，或者从一个WiFi切换到另一个WiFi，然后又切换成数据流量，会话一直都在。 另外一个笔者非常喜欢的特点是–本地响应特别快(intelligent local echo)。笔者有好几台国外的服务器，几乎都是美国的。从中国大陆到美国的Ping值一般都超过200ms，有时候甚至在400ms以上，在这种情况下对比SSH与Mosh的表现： SSH：键盘按下每一个字符，比如“a”，远程服务器接收到本地键盘的响应，然后再告诉本地“这边已接到你按下字母a”，这之后，本地的终端才会显示出字母a。假设Ping值是200ms，那么每次按下按键之后，得有400ms的延迟屏幕才有显示，so，打字一卡一卡的很难受，体验很糟糕。 Mosh：键盘每按下一个字符，屏幕上立马就会显示，发送给远程服务器的工作则在后台静默执行，打字非常流畅。 安装 Mac OS X 从pkg软件包安装：OS X 10.5–10.9 &amp;&amp; OS X 10.9+ HomeBrew：$ brew install mosh MacPorts：$ sudo port install mosh Windows - Cygwin: C:\\&gt; setup.exe -q mobile-shell Chrome浏览器：插件Mosh for Chrome Linux Ubuntu/Debian: $ sudo apt-get install mosh ArchLinux: $ sudo pacman -S mosh CentOS/Fedaro：$ sudo yum install mosh FreeBSD: $ sudo pkg install net/mosh 编译安装 下载源码包进行 123456$ wget https://mosh.mit.edu/mosh-1.2.5.tar.gz$ tar xvzf mosh-1.2.5.tar.gz$ cd mosh-1.2.5$ ./configure$ make# make install 从git拉取源码 123456$ git clone https://github.com/mobile-shell/mosh$ cd mosh$ ./autogen.sh$ ./configure$ make# make install 使用方法 基本上和SSH一模一样，直接$ mosh server-address就好了，因为Mosh的本质还是SSH 如果远程主机的SSH端口不是22，比如是2022，则需要$ mosh remotehost --ssh=&quot;ssh -p 2022&quot; 一般来说，远程主机的环境要配置成en_US.UTF-8，不然会报“mosh requires a UTF-8 locale.”之类的异常，根本用不了。琢磨了好久，研究出一套多平台的解决方案。 Linux 12341. 在/etc/environment中追加一句LC_ALL=&quot;en_US.UTF-8&quot;2.A [Ubuntu/Debian] $ sudo locale-gen en_US.UTF-8 2.B [CentOS/Fedaro] $ sudo localedef -v -c -i en_US -f UTF-8 en_US.UTF-83. reboot FreeBSD：只需在~/.login_conf中追加 1234me:\\ :charset=UTF-8:\\ :lang=en_US.UTF-8:\\ :setenv=LC_COLLATE=C: 踩坑 错误Nothing received from the server on UDP port 60003：简单来说，Mosh的网络通信由两部分组成，TCP用于SSH会话+UDP用于会话保持。TCP部分的端口就是SSH的端口，而UDP的端口则是60000~61000之间的随机数。该错误的解决方案将UDP端口加入防火墙的白名单$ sudo iptables -I INPUT 1 -p udp --dport 60000:61000 -j ACCEPT 笔者家里的那台老MacBook作为文件服务器，常年开着不关机，但是从外网通过Mosh访问回去，会出现找不到mosh-server的异常。原因是笔者用HomeBrew安装的Mosh，执行文件被默认放在/usr/local/bin/下，在高版本的OSX下，因安全方面的考虑，该路径不在系统的初始PATH里，所以会找不到mosh-server。解决方法是“显式指定执行文件的路径”：1$ mosh macbook --server&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;mosh-server 结语自从两年前发现了这么个利器，在笔者的日常运维中，它已经完全替代了SSH的存在。最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"Dev","slug":"Dev","permalink":"https://blog.chaosjohn.com/tags/Dev/"}]},{"title":"安卓平板上的开发者实用工具","slug":"Tools-for-Developers-on-Android-Tablet","date":"2016-05-29T08:52:15.000Z","updated":"2020-11-25T08:49:06.000Z","comments":true,"path":"Tools-for-Developers-on-Android-Tablet.html","link":"","permalink":"https://blog.chaosjohn.com/Tools-for-Developers-on-Android-Tablet.html","excerpt":"","text":"1. 测试机型和本文的受众 你得有一块android平板，或者一只超大屏的android手机(类似小米MAX，其实小米Note也凑合)。 你还得是个开发者，本文介绍的工具都是为开发者准备，如果你不是，请拉到文章末尾，就只给你安利GMD GestureControl这一个软件啦🙈。 本文封面的是笔者的小米平板第一代64G版，于15年“双十一”花1099块大洋买了送给女朋友的，后来公司年终抽奖抽到一块iPad mini2，就从女朋友手里把这块安卓板子换回来了（笔者是标准的暖男嚯嚯嚯）。 笔者绝对没有给小米打广告，相反除了这块MiPad之外，笔者只想狠狠地黑小米，比如小米MAX–这货到底是手机还是平板啊；比如说公司花3000块钱买回来的小米Note顶配版–特喵的一天三充而且果然“为发烧而生”。 只有这块14年问世的MiPad，用下来觉得还好，续航很给力，而且“NVIDIA Tegra K1”的CPU，放到现在16年中旬，还能排上号。 笔者虽然是果粉，但是绝对不鄙视android，相反在各类平板中选择的话，我还是比较偏好android的。原因无他，用的顺手。（以后我会写篇文章讲讲我为什么平板选择android，而手机却选择iPhone） 2. 系统版本 小米平板嘛，出厂必须自带MIUI滴。 想把小米平板变成“PC”，还刷过一次RemixOS，但是因为官方没有支持MiPad，只有民间大神制作的兼容包，还只有1.0版本的，虽然用着体验挺好的，最后实在架不住某些蛋疼的bug，还是刷回了MIUI系统。关于RemixOS，如果有感兴趣的，可以去官网下载他们的PC版，安装到u盘上直接插电脑体验，不建议刷到大家的平板上。 为了Root，所以刷了MIUI的开发版本，已升级到MIUI7(Android 4.4.4)，删除了系统的Updater.apk，禁用了自动更新。 3. 必装应用列表 谷歌安装器（需root）：给国内被阉割的安卓系统安装“谷歌服务框架”和“谷歌应用市场”。 ES File Explorer：笔者在安卓平台上用过的最好用的文件管理器，给开发者推荐的原因如下 方便管理已安装应用，还可以备份应用（包括应用数据） 支持ftp/sftp，方便连接本地局域网的电脑或云端的Linux主机，进行传输文件。 Root Explorer（需root）：俗称“RE管理器”，可以直接将系统路径挂载为可写，还可以原生读取应用的db文件。 AirDroid：无线传输文件和管理安卓设备。 从电脑上查看安卓设备的内容（照片、收发短信等） 把电脑当做平板的“键盘”，当电脑上点中Airdroid的窗口后，电脑键盘的输入都会同步到平板上去。 Hacker’s Keyboard：“黑客键盘”，模拟标准的PC键盘，包括F1~F12，ctrl，alt，shift，tab等功能键。非常实用。 Serverauditor：SSH客户端，配色非常小清新，而且跨平台，在iOS和chrome上都有。还能自动判别所连接的主机是什么系统并且给相应的主机加上对应系统的Logo。 ConnectBot：也是一款SSH客户端，官方Github的介绍为“ConnectBot is the first SSH client for Android”。功能比Serverauditor强大，而且Hacker’s Keyboard专门为其做了优化（详见Hacker’s Keyboard的设置页）。 IrssiConnectBot：以ConnectBot为原型的SSH客户端，增加了mosh协议。切记，千万不要去GooglePlay商店安装，那里下载的版本和最基础的ConnectBot一毛一样，根本就没有mosh！请到IrssiConnectBot的官网下载或者点击此处下载或者去它的Github下载源码到本地自己编译。 JuiceSSH：看名称就知道它也是一款SSH客户端了，同样支持mosh协议，而且是mosh官网推荐的mosh客户端。功能非常强大，还支持插件。但是！笔者不喜欢JuiceSSH，因为笔者远程管理主机一般都会使用到Tmux，需要按缀键Ctrl-B来激活，但是JuiceSSH不识别同时按下的Ctrl键和B键，故抛弃。但不妨碍它成为GooglePlay上最畅销的SSH客户端之一。 Shadowsocks：不解释，懂得人自然懂，不懂的人，有“病”的话搜索一下（哈哈哈，其实是bing.com），百度该词已被和谐。当然建议从GooglePlay上安装。 BusyBox（需root）：BusyBox 被称为 Linux 工具里的瑞士军刀.简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令。Android的本质是Linux，但其底层的一些工具不仅较标准的Linux少很多，已有的几乎也是功能不完善的。BusyBox的作用就是补全和替换掉这些Linux工具。 Linux Deploy（需root和安装BusyBox）：最后祭上的终极杀器，官方Github。简单一句话介绍–“在你的安卓设备上原生跑Linux”。基本原理–“chroot”，想详细了解的可以从这个关键词入手。可以选择的Linux发行版有很多，主流的都有，包括Debian、Ubuntu、CentOS、Arch Linux、Gentoo等等，安装完成后可以通过127.0.0.1:22进行SSH登入。如果平板的空间足够的话，可以同时安装很多个(如下图所示，笔者安装了Arch Linux、Ubuntu和Gentoo)，但只能同时选择一个运行。 GMD GestureControl Lite（需root）：最后的最后，送上的一枚手势软件（并非只为开发者推荐哦）。这边给出的链接是Lite版（非Lite版要价5.55美元），但是Lite版就够用了。羡慕iPad的各种手势吗？四指内抓退回桌面、四指左右横扫切换上一个应用和下一个应用、四指上推显示最近应用列表。。。有了这个软件，这些功能你都能实现！而且实现的更多！简直堪比iOS的越狱插件Activator！ 4. 结语其实还有很多很多其他为开发者准备的软件，如果有读者愿意推荐的话，请在下面给我留言啦，小弟不胜感激！最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"Utility","slug":"Utility","permalink":"https://blog.chaosjohn.com/tags/Utility/"},{"name":"Android","slug":"Android","permalink":"https://blog.chaosjohn.com/tags/Android/"},{"name":"Developer","slug":"Developer","permalink":"https://blog.chaosjohn.com/tags/Developer/"}]},{"title":"只为体验小红点--我的“ThinkPad X200”","slug":"My-ThinkPad-X200","date":"2016-05-28T08:50:50.000Z","updated":"2020-11-26T01:11:15.000Z","comments":true,"path":"My-ThinkPad-X200.html","link":"","permalink":"https://blog.chaosjohn.com/My-ThinkPad-X200.html","excerpt":"","text":"1. 手贱入坑X200 之前逛知乎逛论坛，经常看到有两拨人打口水仗，非得就“MacBook的触控板和Thinkpad的小红点哪一个好用”争个脸红耳赤。（前者为TrackPad，后者为TrackPoint） 作为一个已经用了四五年MacBook的果粉，笔者之前一直觉得TrackPad是史上最好用的电脑输入设备。以至于笔者一直是TrackPad的重度使用者，电脑包里只有MacBook而从来不携带鼠标，也从来没有使用鼠标的习惯。（PS：笔者是一只非常稀少的不打游戏的雄性程序猿） 看多了“TrackPad Vs. TrackPoint“之争，自然心里痒痒的。咋办哩？那就买一台体验体验！可是ThinkPad还挺贵的，买一台大几千呢，笔者可是勤俭持家的好男人，老婆本可不能随便动。。。于是默默地掏出爪机刷起了闲鱼(🙈捂脸逃) 选机上，笔者看中了ThinkPad X200，经典的小黑，百度百科链接 Intel(R) Core(TM)2 Duo CPU – 至少不是赛扬奔腾之类的处理器 Intel GMA X4500显卡 – 都说了笔者不打游戏了，要独显干嘛，浪费钱？ DDR3 – 还好不是DDR2，不然升级低版本的内存得死贵死贵的，还记得之前有买过一根DDR333的1G内存都花了两百左右 只有TrackPoint，没有触摸板 – 要是有触摸板的话，我怕自己会下意识的用它，那算哪门子的体验小红点呀 闲鱼上的X200大多在600块钱左右，如果配备SSD，价格差不多都飙到八九百，一千多的也有很多。笔者的价格底线是500，唉，怎么那么穷！ X200在笔者的“欲购清单”上待了大半年，时不时地就来闲鱼看看有没有合适的(佩服自己的耐心)。终于在三周前，联系到了一位卖家，与他商议不要内存不要硬盘（笔者有闲置的内存条和硬盘），于是以290的价格成交（包邮）。哇咔咔！ 一周星期的焦急等待后，盼来了X200。拆机，包的还挺严实，打开，按下电源键，还有电，关机。打开后盖，有两个内存插槽，随便插上一根4G的内存，再次开机，居然提示内存错误。原来两个内存插槽还分0号和1号，必须从0号开始使用起。晕死，换了个内存插槽，果然没问题了。再换成两根2G的，也没问题。玩过这么多电脑，还是第一次见到这种状况。随便找个了装了Linux Live的u盘，能正常进入系统，蓝牙Wifi工作都正常。 2. X200初体验 先说说缺点 有两个按键太灵敏，X和K，轻轻碰上去都会打出x和k的字母。X键太灵敏能忍，但是作为VIM党，K键太灵敏就不能忍！扣下键帽，用缝衣针把里面的脏东西挑出来，吹风机吹吹，按回去，居然好了！于是，此缺点从此消失。 底部靠近电源的一个防滑橡胶脚垫掉了，电脑放在桌子上会不稳，经常会有“卡拉卡拉”和桌面轻碰的声音。于是上某宝花了几块钱买了个相同型号的脚垫。该缺点也从此消失。 电池是6芯的，设计容量1723mAh，剩余容量1470mAh，仅为原来的85%，续航只能撑2个小时不到。这个缺点等以后真正有续航需求的时候再考虑解决吧，买个9芯的电池也就一两百块钱。 找不到其他缺点了😀 以下开始进入“拍马屁模式” 成色非常好（见封面图），键盘完全没有油光，用酒精把整机擦拭了一遍后，保守估计95新吧，噢耶赚到了，闲鱼上很多卖的很贵的，看成色都很旧很脏。 重量很轻，1.394KG，笔者的MacBook Air重量也达到了1.35KG，只差44g（脑海里莫名地想起初中物理课本，一个鸡蛋50g） 笔者买的这台X200是P8600的CPU，性能比最早的i3都要强。。。笔者最早的一台MacBook是经典款的“小白”MC207，P7550的CPU，用到现在为止都依然“坚挺”！ 键盘手感很好，比Mac的原装键盘要好，键程适中，弹性不错，手感偏软。 散热真赞！发热真小！电脑开一整天，C面(有键盘的那一面)没有丝毫热感，D面(电脑底部)感觉和人的体温差不多，出风口几乎没有很大的风吹出来，导致整机非常静音，丝毫没有其他电脑风扇为了散热狂转造成的噪音。 Wifi居然支持2.4GHz和5GHz双频段！！！天哪，08年的电脑啊！！！ 3. 体验小红点 其实说是说小红点，但不仅仅是在按键“B”上方的红色的橡胶点，还包括了空格下方的三个按键，从左往右分别对应鼠标的左键、中键和右键。如下图所示。 按住小红点，手指往哪边用力，光标就会往哪边移动。一开始真的很难把握移动的角度和速度，总是很难非常快速地把光标移动到目标位置，用力小了，移动地太慢，用力大了，一下子就移动过头了。还好没有买带触摸板的型号，强迫自己使用小红点半天不到，就差不多能顺畅使用它了。 左键和右键的功能就不说了，如果在浏览网页或文档时，按住中键后再给小红点用力，就能滚屏啦。“哗哗哗”非常顺畅，个人感觉比鼠标滚轮要好用得多，简直能媲美MacBook触控板的双指滚屏，很是喜欢！ 因为尚未在X200上安装过Windows，所以关于小红点在Windows下的表现笔者不进行描述，一般要去ThinkPad官网下载相关驱动以启动。 因为快递刚收到的时候，笔者为了测整机质量，所以就用了一块Linux LiveUSB进行启动，操作系统为最新的Ubuntu 16.04，内置了TrackPoint的驱动，小红点的所有功能都能正常使用。所以读者如果安装Ubuntu系列的操作系统的话，是不用费心再安装相关驱动的，开箱即用。 笔者收到快递当天就在某东买了块120GB的SSD，于是就在这块硬盘上安装了Arch Linux。 Arch Linux的安装不再赘述，直接参照Arch Wiki的新手教程即可，以后有机会我会写篇比较浅显易懂的文章。 那么问题来了，小红点在Arch Linux下只能用作移动光标，而不能用来滚动屏幕。真是愁死了，废了好大劲安装了Arch Linux，结果却不能完全发挥小红点的威力。 在Google上搜索了一番，终于找到了解决方案，在命令行下输入以下开启垂直滚动 123456789 xinput set-prop &quot;TPPS/2 IBM TrackPoint&quot; &quot;Evdev Wheel Emulation&quot; 1 xinput set-prop &quot;TPPS/2 IBM TrackPoint&quot; &quot;Evdev Wheel Emulation Button&quot; 2 xinput set-prop &quot;TPPS/2 IBM TrackPoint&quot; &quot;Evdev Wheel Emulation Timeout&quot; 200 ``` * 如果还想开启水平滚动的话，执行 ```bash xinput set-prop &quot;TPPS/2 IBM TrackPoint&quot; &quot;Evdev Wheel Emulation Axes&quot; 6 7 4 5 以上这些xinput命令不是永久性的，每次图形界面(xserver)重启，都得重新执行才能生效。但可以放在.xsessionrc内，当xserver启动时会自动执行。 当然，如果不喜欢命令行的话，也有图形界面程序来解决啦。有两个选择，GPointing Device Settings和configure-trackpoint。笔者在Arch Linux上安装了前者，如下图所示 4. 结语体验下来，MacBook和ThinkPad都很赞，现在这台290收来的X200已经成为了笔者的半个主力机，晚上下班回去，如果不写博客的话，大多数时间是抱着ThinkPad。如果读者也想体验体验的话，上闲鱼收个X200是个很不错的选择，当然，X61也可以考虑哦，虽然性能比X200差，但是最近民间有“厂子”有在开发号称“X62”的主板，具体详见 。最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Toy","slug":"Toy","permalink":"https://blog.chaosjohn.com/tags/Toy/"},{"name":"Hardware","slug":"Hardware","permalink":"https://blog.chaosjohn.com/tags/Hardware/"},{"name":"ThinkPad","slug":"ThinkPad","permalink":"https://blog.chaosjohn.com/tags/ThinkPad/"},{"name":"TrackPoint","slug":"TrackPoint","permalink":"https://blog.chaosjohn.com/tags/TrackPoint/"}]},{"title":"HomeBrew -- OSX下的最强软件包管理器","slug":"HomeBrew-The-Best-Package-Manager-On-OSX","date":"2016-05-26T09:23:57.000Z","updated":"2020-11-26T06:51:28.166Z","comments":true,"path":"HomeBrew-The-Best-Package-Manager-On-OSX.html","link":"","permalink":"https://blog.chaosjohn.com/HomeBrew-The-Best-Package-Manager-On-OSX.html","excerpt":"","text":"1. 什么是软件包管理器软件包管理器（以下简称包管理器），是用来管理系统下面软件和程序的工具，负责它们的搜索、安装、更新升级和卸载。 2. 为什么需要包管理器 包管理器一般来说是*nix系统(Unix-like: Linux, Mac OS X, FreeBSD等等)独有的。 Windows的软件生态系统决定了它不需要包管理器，大部分用户都是用它的图形界面，他们所需要做的就是在获取到该软件的安装包(Installer)后，运行后”Next”-&gt;”Next”-&gt;…-&gt;”Finish”，直至安装到某个路径下，创建软件的启动器快捷方式。 *nix系统中除了Mac OS X(以下简称OSX)外，其他的系统的主要用途是作为服务器，用Linux做桌面系统来用的家伙不会很多，大部分都是像我这样的苦逼程序猿，用FreeBSD当桌面使用的更是少之又少。那么作为服务器来用的话，一般都不配备图形界面的，只有命令行接口。原因有二：一、图形界面耗性能啊；二、一般服务器都架在云端，你开个图形界面远程登录上去，鼠标拖动都一卡一卡的，那画面，真是太美不忍看。所以一般的Linux的发行版和FreeBSD都提供了包管理器，让用户能在命令行下比较轻松地管理软件（Debian: apt-get, Redhat/CentOS/Fedora: yum, ArchLinux: pacman）。。。呃，那些热衷于任何软件都要从源代码安装的家伙，有毒，我服！ 不知道是谁说过来着：“MacBook的死忠用户主要有两类：搞设计的和搞IT的”。。。既然搞IT，那肯定离不开命令行。对于我们程序猿来说，OSX真是一个绝妙的组合，既有非常美丽易用的GUI，又有纯*nix的命令行。像ngnix和apache等等这些命令行软件，OSX“出厂”时是没有的，所以要么从下载它们的源代码编译安装，要么就用包管理器来安装。 3. OSX下有哪些包管理器 __MacPorts__：源于BSD的ports，纯源码编译安装。用简单的话来说，它帮你计算目标软件所需要的依赖，然后把所有依赖和目标软件依次下载源码编译安装。它的优点很明显，软件不依赖操作系统本身，升级系统版本一般不会破坏软件体系；同时缺点也很明显，无论安装还是更新软件，编译源代码实在是太费时间了，笔者的第一台Macbook是09年的经典小白mc207，酷睿P7550的CPU，每次升级MacPorts都只敢在晚上睡觉时进行。MacPorts是笔者最早使用的，陪伴了将近三年时间。最后放弃的原因不是编译费时，而是系统升级到了Yosemite和El Capitan后，有很多软件死活编译不通过，无法更新。 Fink: 很抱歉笔者没有用过，所以在这里我只放科普贴的简介Fink是基于Debian的packaging tools开发的。最大的特点是安装软件是预编译好的(pre-compiled/pre-built)。 所以，用Fink安装package是不需要在本机编译的，都是现成的binary code。 Fink最大的问题是package跟进不够快。很多最新版的软件，你要等Fink。 HomeBrew: 哈哈哈，有些读者都要怪我啰嗦了，这么半天才开始文章的主要角色。HomeBrew是基于Ruby语言写的，从包管理的特色上来看，它似乎是Macports和Fink俩生的儿子 😂。在依赖处理上，它尽量使用系统原有的库，如果系统不提供，它才安装依赖；安装时优先选择已编译好的二进制包，如果没有它才下载源码进行编译安装。 4. 安装HomeBrew 笔者之前介绍过，HomeBrew是用Ruby写的，而OSX内置了Ruby，所以打开终端(Terminal)，把/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;复制粘贴进去，回车执行，That’s all。 5. HomeBrew基础命令 笔者在这边以安装wget举例（OSX居然没有集成wget，真有点不爽） brew search wget 搜索软件，列出所有包含目标名称的软件 brew install wget 安装软件，默认安装到/usr/local下面去 brew info wget 查看安装包信息 brew uninstall wget 卸载软件 brew update 更新所有软件列表（HomeBrew使用git，直接从github上pull下来） brew upgrade 升级所有软件 brew cleanup 清理 brew list 列出所有通过HomeBrew安装的软件 brew doctor 检查HomeBrew是否存在问题 6. 笔者用HomeBrew安装的软件推荐列表 wget 不再赘述 htop top的高级版，更直观，是一款用来监测系统的CPU、内存、uptime、进程等系统信息的工具 tree 以树状形式列出文件目录树 tmux 终端复用软件，神器，谁用谁知道 hardlink-osx 让你给目录加硬链接，对，你没听错，目录！ macvim vim在OSX下的GUI版本，做了很多OSX的本地化，比如cmd+w关闭等等 mpg123 mpg321 名字很秀逗的两个软件，命令行音乐播放器，可以用来装个逼😀 mplayer mpv 两个非常棒的多媒体播放器，个人更偏好后者 mtr traceroute的加强版 nvm 对node进行多版本管理 python3 OSX下安装Python3最为方便的方法了 7. Cask – HomeBrew的大杀器 一句话介绍：用来安装各种OSX应用程序的工具，例如Chrome, Firefox，MysqlWorkbench。 安装Cask：brew tap phinze/homebrew-cask &amp;&amp; brew install brew-cask 使用（以Chrome举例）： brew cask search chrome 搜索应用，结果显示我们要安装google-chrome brew cask install google-chrome 安装应用 brew cask uninstall google-chrome 卸载应用 brew update 更新所有应用列表 brew cleanup 清理 Cask相比brew缺少了upgrade命令，所以这边奉上一行shell脚本，用来升级所有用Cask安装的应用程序 for c in $(brew cask list); do ! brew cask info $c | grep -qF &quot;Not installed&quot; || brew cask install $c; done 8. 结语HomeBrew以给我节省了很多找软件和安装软件的时间，导致我对它越来越喜欢，以至于，我系统里一切能用HomeBrew搜索到的软件，我全用它来搞定了。关于这篇博文，我觉得对某些人来说，那句给Cask进行upgrade的shell脚本，是最具有价值的。（那就~考虑给我点捐助进行鼓励吧，一元两元不嫌少，一百两百不嫌多）","categories":[],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"}]},{"title":"上手Hexo","slug":"Getting-Started-With-Hexo","date":"2016-01-28T14:18:28.000Z","updated":"2020-11-25T09:44:14.000Z","comments":true,"path":"Getting-Started-With-Hexo.html","link":"","permalink":"https://blog.chaosjohn.com/Getting-Started-With-Hexo.html","excerpt":"","text":"这篇文章主要记载一下我如何上手Hexo(搭建本博客的技术)。 前期准备 NodeJS GitHub (已配置好SSH接入，详情参考GitHub官网) 域名 (可选项，下面会说明何时必须要求绑定域名) 开始安装Hexo$ npm install -g hexo 在GitHub上创建博客仓库此时得考虑两种选择： GitHub Pages (每个GitHub账号只能创建一个，即该仓库的默认分支master就是博客，而且仓库名是固定为username.github.io)。如果博客搭建成功，浏览器访问https://username.github.io就能打开博客。 gh-pages (可以创建无限多个，每个仓库都能创建一个静态博客，但是博客必须在gh-pages分支下)。在这种情况下，博主必需使用域名通过CNAME解析你的博客仓库，否则文章的CSS样式路径会出错，导致整个页面会是下面这种没有样式的样子 在本地部署 在本地clone你创建的GitHub仓库 默认为master分支，如果你使用的是gh-pages，需要切换到gh-pages分支。$ git branch gh-pages &amp;&amp; git checkout gh-pages 初始化hexo $ hexo init，并且调用npm安装相应的node_modules $ npm install 开启服务器进行本地预览（此时hexo默认生成了一篇Hello-World博客）$ hexo server，浏览器打开localhost:4000就能看到效果博客效果。建议操作博客时关闭服务器(ctrl-c)。 新增博客$ hexo new &quot;new blog name&quot;，hexo会生成以new-blog-name.md为名的博客 部署到GitHub 编辑博客仓库根目录下的_config.yml文件，在末尾追加变成为 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:username/blog.git branch: master 为避免下一步骤出现 ERROR Deployer not found : git的报错，需要安装git部署模块$ npm install hexo-deployer-git --save 生成静态文章$ hexo generate 部署到GitHub`$ hexo deploy` 测试博客 如果搭建的是GitHub Pages，则直接访问https://username.github.io即可 如果搭建的是gh-pages，则还需配置域名，比如笔者的域名为chaosjohn.com。 在域名的DNS解析内新增两条A记录，指向GitHub Pages提供的IP 192.30.252.153 192.30.252.154 接着在DNS解析内新增一条CNAME记录，记录名比如使用blog，记录值为username.github.io，添加完后可能会在记录值追加一个’.’，不用纠结，这个就是CNAME的格式。 在博客仓库的source文件夹内新建一个CNAME文件，文件内容就是blog.chaosjohn.com 重新生成静态文章并且部署到GitHub，可以使用快捷命令$ hexo d -g 命令集合 常用命令 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 复合命令 hexo deploy -g #生成加部署 hexo server -g #生成加预览 命令简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy (各位大侠行行好给点捐助吧）","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.chaosjohn.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-01-28T13:18:28.000Z","updated":"2020-11-25T08:45:08.000Z","comments":true,"path":"hello-world.html","link":"","permalink":"https://blog.chaosjohn.com/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"debug","slug":"debug","permalink":"https://blog.chaosjohn.com/tags/debug/"},{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"xdebug","slug":"xdebug","permalink":"https://blog.chaosjohn.com/tags/xdebug/"},{"name":"dev","slug":"dev","permalink":"https://blog.chaosjohn.com/tags/dev/"},{"name":"package manager","slug":"package-manager","permalink":"https://blog.chaosjohn.com/tags/package-manager/"},{"name":"network","slug":"network","permalink":"https://blog.chaosjohn.com/tags/network/"},{"name":"tool","slug":"tool","permalink":"https://blog.chaosjohn.com/tags/tool/"},{"name":"port-forwarding","slug":"port-forwarding","permalink":"https://blog.chaosjohn.com/tags/port-forwarding/"},{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"APFS","slug":"APFS","permalink":"https://blog.chaosjohn.com/tags/APFS/"},{"name":"shell","slug":"shell","permalink":"https://blog.chaosjohn.com/tags/shell/"},{"name":"Virtualization","slug":"Virtualization","permalink":"https://blog.chaosjohn.com/tags/Virtualization/"},{"name":"IPv6","slug":"IPv6","permalink":"https://blog.chaosjohn.com/tags/IPv6/"},{"name":"VMware","slug":"VMware","permalink":"https://blog.chaosjohn.com/tags/VMware/"},{"name":"iCloud","slug":"iCloud","permalink":"https://blog.chaosjohn.com/tags/iCloud/"},{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://blog.chaosjohn.com/tags/Homebrew/"},{"name":"Skills","slug":"Skills","permalink":"https://blog.chaosjohn.com/tags/Skills/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.chaosjohn.com/tags/hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.chaosjohn.com/tags/Nginx/"},{"name":"Crack","slug":"Crack","permalink":"https://blog.chaosjohn.com/tags/Crack/"},{"name":"Java","slug":"Java","permalink":"https://blog.chaosjohn.com/tags/Java/"},{"name":"Gradle","slug":"Gradle","permalink":"https://blog.chaosjohn.com/tags/Gradle/"},{"name":"Error","slug":"Error","permalink":"https://blog.chaosjohn.com/tags/Error/"},{"name":"Dev","slug":"Dev","permalink":"https://blog.chaosjohn.com/tags/Dev/"},{"name":"Utility","slug":"Utility","permalink":"https://blog.chaosjohn.com/tags/Utility/"},{"name":"Android","slug":"Android","permalink":"https://blog.chaosjohn.com/tags/Android/"},{"name":"Developer","slug":"Developer","permalink":"https://blog.chaosjohn.com/tags/Developer/"},{"name":"Toy","slug":"Toy","permalink":"https://blog.chaosjohn.com/tags/Toy/"},{"name":"Hardware","slug":"Hardware","permalink":"https://blog.chaosjohn.com/tags/Hardware/"},{"name":"ThinkPad","slug":"ThinkPad","permalink":"https://blog.chaosjohn.com/tags/ThinkPad/"},{"name":"TrackPoint","slug":"TrackPoint","permalink":"https://blog.chaosjohn.com/tags/TrackPoint/"},{"name":"fix","slug":"fix","permalink":"https://blog.chaosjohn.com/tags/fix/"},{"name":"composer","slug":"composer","permalink":"https://blog.chaosjohn.com/tags/composer/"},{"name":"git","slug":"git","permalink":"https://blog.chaosjohn.com/tags/git/"}]}